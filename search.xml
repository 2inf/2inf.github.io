<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[浅谈几个特殊函数]]></title>
    <url>%2F2019%2F08%2F28%2F%E6%B5%85%E8%B0%88%E5%87%A0%E4%B8%AA%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[\(\Gamma函数\) \(\Gamma\)函数是由如下含参数变量定义的积分, 又称第二类\(Euler\)积分 \[\Gamma(s)=\int_0^{+\infty}x^{s-1}e^{-x} \tag{1}\] 性质: \(\Gamma(s+1)=s\Gamma(s)\ (s&gt;0)\) \(\Gamma(s)=2\displaystyle\int_0^{+\infty}x^{2s-1}e^{-x^2}dx\) \(\rm{B}函数\) \({\rm{B}}\)函数是由如下含两个参变量的瑕积分定义的函数 \[{\rm{B}}\left(p,q\right)=\int_0^1x^{p-1}(1-x)^{q-1},\quad p,q&gt;0 \tag{2}\] 性质: \({\rm{B}}(p,q)={\rm{B}}(q,p)\) \({\rm{B}}(p,q)=\displaystyle\frac{p-1}{p+q-1}{\rm{B}}(p-1,q)\) \({\rm{B}}(p,q)=2\displaystyle\int_0^\frac{\pi}{2}\cos^{2p-1}\theta\sin^{2q-1}\theta d\theta\) \({\rm{B}}(p,q)=\displaystyle\int_0^{+\infty}\frac{x^{q-1}}{(1+x)^{p+q}}dx\) 二者的关系 设\(p&gt;0,q&gt;0\)则有\({\rm{B}}(p,q)=\displaystyle\frac{\Gamma(p)\Gamma(q)}{\Gamma(p+q)}\) 证明: 由性质知 \[\Gamma(p)=2\int_0^{+\infty}x^{2p-1}e^{-x^2}dx,\quad\Gamma(q)=2\int_0^{+\infty}x^{2q-1}e^{-x^2}dx\] 令\(D=\left\{(x,y):0\leq x&lt;+\infty,0\leq y&lt;+\infty\right\}\), 则有 \[\Gamma(p)\Gamma(q)=4\iint_Dx^{2p-1}y^{2q-1}e^{-(x^2+y^2)}dxdy\] 利用极坐标变换, 记\(D_1=\displaystyle\left\{(r,\theta):0&lt;r&lt;+\infty,0\leq\theta\leq\frac{\pi}{2}\right\}\), 则有 \[\begin{array}{l} \Gamma(p)\Gamma(q)&amp;=&amp;4\displaystyle\iint_{D1}r^{2(p+q)-1}e^{-r^2}\cos^{2p-1}\theta\sin^{2q-1}\theta drd\theta\\ &amp;=&amp;\displaystyle\left(2\int_0^\frac{\pi}{2}\cos^{2p-1}\theta\sin^{2q-1}\theta d\theta\right)\left(2\int_0^{+\infty}r^{2(p+q)-1}e^{-r^2}dr\right)\\ &amp;=&amp;\displaystyle{\rm{B}}(p,q)\Gamma(p+q) \end{array}\] 证毕. (余元公式) 设\(0&lt;p&lt;1\), 则有 \[{\rm{B}}(p,1-p)=\Gamma(p)\Gamma(1-p)=\frac{\pi}{\sin p\pi}.\] 证明: 由于\({\rm{B}}(p,1-p)=\displaystyle\int_0^{+\infty}\frac{x^{p-1}}{1+x}dx\), 利用变量替换\(x=\frac{1}{t}\)有: \[\int_1^{+\infty}\frac{x^{p-1}}{1+x}dx=\int_0^1\frac{x^{-p}}{1+x}dx,\] 将\(\displaystyle\frac{1}{1+x}\)展开成幂级数, 从而有 \[\begin{array}{l} {\rm{B}}(p,1-p)&amp;=&amp;\displaystyle\lim_{r\to1^-}\int_0^r\frac{x^{p-1}+x^{-p}}{1+x}dx\\ &amp;=&amp;\displaystyle\lim_{r\to1^-}\int_0^r\left[\sum_{k=0}^{+\infty}(-1)^kx^{k+p-1}+\sum_{k=0}^{+\infty}(-1)^kx^{k-p}\right]dx\\ &amp;=&amp;\displaystyle\lim_{r\to1^-}\left[\sum_{k=0}^{+\infty}\frac{(-1)^k}{k+p}r^{k+p}+\sum_{k=0}^{+\infty}\frac{(-1)^k}{k-p+1}r^{k-p+1}\right]\\ &amp;=&amp;\displaystyle\sum_{k=0}^{+\infty}\frac{(-1)^k}{k+p}+\sum_{k=0}^{+\infty}\frac{(-1)^k}{k-p+1}\\ &amp;=&amp;\displaystyle\frac{1}{p}+\sum_{k=1}^{+\infty}(-1)^k\left(\frac{1}{k+p}+\frac{1}{p-k}\right)\\ &amp;=&amp;\displaystyle\frac{1}{p}+\sum_{k=1}^{+\infty}(-1)^k\frac{2p}{p^2-k^2}. \end{array}\] 而\(\cos px\)的\(Fourier\)级数为 \[\cos px=\frac{\sin px}{\pi}\left[\frac{1}{p}+\sum_{k=1}^{+\infty}(-1)^k\frac{2p}{p^2-k^2}\cos kx\right]\] 在\(\left|x\right|\leq\pi\)处处收敛, 令\(x=0\)即得 \[{\rm{B}}(p,1-p)=\frac{1}{p}+\sum_{k=1}^{+\infty}(-1)^k\frac{2p}{p^2-k^2}=\frac{\pi}{\sin p\pi}.\] 证毕.]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[反演原理及应用]]></title>
    <url>%2F2019%2F08%2F25%2F%E5%8F%8D%E6%BC%94%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[什么是反演 对于数列\(\left\{f_n\right\}\)以及数列\(\left\{g_n\right\}\)满足 \[g_n=\sum_{i=0}^na_{ni}f_i \tag{1}\] 反演便是利用\(\left\{g_n\right\}\)反推出\(\left\{f_n\right\}\), 也即 \[f_n=\sum_{i=0}^nb_{ni}g_i \tag{2}\] 本质上来说这是一个反解线性方程组的过程, 但观察后会发现整个方程组是一个下三角矩阵, 可以思考出更加快捷的方法 反演原理 为了便于后面的叙述, 首先引入\(\delta(i,j)\)函数\((Kronecker&#39;s\ delta)\), 它的定义为 \[\delta\left(i,j\right)=\begin{cases}1\quad i=j\\0\quad i\neq j\end{cases}\qquad(\text{也可记为}[i=j])\] 下面考虑反演的过程, 考虑下面的式子应该满足什么条件 \[ \sum_{i=0}^nb_{ni}g_i=f_n \tag{3} \] \[ \begin{array}{l} LHS&amp;=&amp;\displaystyle\sum_{i=0}^nb_{ni}g_i\\ &amp;=&amp;\displaystyle\sum_{i=0}^nb_{ni}\sum_{j=0}^ia_{ij}f_j\\ &amp;=&amp;\displaystyle\sum_{i=0}^nf_i\sum_{j=i}^nb_{nj}a_{ji} \end{array} \] 为了便于理解最后一步, 我们用矩阵进行表示 \[ \begin{bmatrix} b_{n0}a_{00}f_0\\ b_{n1}a_{10}f_0 &amp; b_{n1}a_{11}f_1\\ b_{n2}a_{20}f_0 &amp; b_{n2}a_{21}f_1 &amp; b_{n2}a_{22}f_2\\ \vdots &amp; \vdots &amp; \ddots \\ b_{nn}a_{n0}f_0 &amp; b_{nn}a_{n1}f_1 &amp; \cdots &amp; b_{nn}a_{nn}f_n \end{bmatrix} \] 前一个是对行进行, 再将行加起来, 后一个是对列进行, 再将列加起来 因此, 式\((3)\)成立的条件等价于 \[\sum_{j=i}^nb_{nj}a_{ji}=\delta(n,i) \tag{4}\] 同理, 将\(f\)代入带\(g\)的求和式中, 可以推出 \[\sum_{j=i}^na_{nj}b_{ji}=\delta(n,i) \tag{5}\] 如果某个数列满足上面的条件, 我们便阔以利用反演公式 二项式反演 二项式反演\((binomial\ inversion)\)在容斥中经常用到, 可以表示为 \[ f_n=\sum_{i=0}^n\left(-1\right)^n\begin{pmatrix}n\\i\end{pmatrix}g_i\Leftrightarrow g_n=\sum_{i=0}^n\left(-1\right)^n\begin{pmatrix}n\\i\end{pmatrix} f_i \tag{6} \] 可以写成另一种常见形式 \[ f_n=\sum_{i=0}^n\begin{pmatrix}n\\i\end{pmatrix}g_i\Leftrightarrow g_n=\sum_{i=0}^n\left(-1\right)^{n-i}\begin{pmatrix}n\\i\end{pmatrix}f_i \tag{7} \] 证明: \[\begin{array}{l} g_n&amp;=&amp;\displaystyle\sum_{i=0}^n\left(-1\right)^{n-i}\begin{pmatrix}n\\i\end{pmatrix}f_i\\ &amp;=&amp;\displaystyle\sum_{i=0}^n\left(-1\right)^{n-i}\begin{pmatrix}n\\i\end{pmatrix}\sum_{j=0}^i\begin{pmatrix}i\\j\end{pmatrix}g_j\\ &amp;=&amp;\displaystyle\sum_{i=0}^ng_i\sum_{j=i}^n\begin{pmatrix}n\\j\end{pmatrix}\begin{pmatrix}j\\i\end{pmatrix}\left(-1\right)^{n-j}\\ &amp;=&amp;\displaystyle\sum_{i=0}^ng_i\sum_{j=i}^n\begin{pmatrix}n\\i\end{pmatrix}\begin{pmatrix}n-i\\j-i\end{pmatrix}\left(-1\right)^{n-j}\\ &amp;=&amp;\displaystyle\sum_{i=0}^ng_i\begin{pmatrix}n\\i\end{pmatrix}\sum_{j=0}^{n-i}\begin{pmatrix}n-i\\j\end{pmatrix}\left(-1\right)^{n-i-j}\\ &amp;=&amp;\displaystyle\sum_{i=0}^ng_i\begin{pmatrix}n\\i\end{pmatrix}\left(1-1\right)^{n-i}\\ &amp;=&amp;g_n \end{array}\] 应用 错位排列 对于长度为\(n\)的序列\(\{a_i\}\), 求所有满足\(1\leq i\leq n\), 使得\(a_i\neq i\)的种类数 一个高中生想到的常规方法可能是利用递推, 记所求为\(D_n\), \(n\)个错位排列按照第一位是\(2,3,\cdots,n\)分成\(n-1\), 每个组排列个数一样多, 考虑其中一组, 不妨设第一位为\(2\), 若第\(2\)位是\(1\),有\(D_{n-2}\)种, 否则有\(D_{n-1}\)种, 结合\(D_1=0,\ D_2=1\), 从而有 \[D_n=(n-1)(D_{n-1}+D_{n-2}) \tag{8}\] \[D_n-nD_{n-1}=-\left(D_{n-1}-(n-1)D_{n-2}\right)=\cdots=(-1)^{n-2} \tag{9}\] \[D_n=nD_{n-1}+(-1)^n=\cdots=n!\sum_{i=0}^n\frac{(-1)^i}{i!} \tag{10}\] 回到正题, 我们有一个有意思的解法, 设\(f_i\)为恰好有\(i\)个位置是不变的排列, 那么 \[n!=\sum_{i=0}^n\begin{pmatrix}n\\i\end{pmatrix}f_i \tag{11}\] 可以看粗其形式和反演公式很像, 令\(g_i=i!\), 有二项式反演 \[\begin{array}{l} f_n&amp;=&amp;\displaystyle\sum_{i=0}^n(-1)^{n-i}\begin{pmatrix}n\\i\end{pmatrix}g_i\\ &amp;=&amp;\displaystyle\sum_{i=0}^n(-1)^{n-i}\frac{n!}{(n-i)!}\\ &amp;=&amp;n!\displaystyle\sum_{i=0}^n\frac{(-1)^i}{i!} \end{array} \] 染色问题 \(n\)个球排成一行, 有\(m\)种颜色, 每个球染一个颜色, 相邻两个球染不同颜色, 每种颜色至少使用一次, 求染色方案数 不考虑每种颜色至少用一次这一条件, 那么答案显然是\(m(m-1)^{n-1}\), 设\(f_i\)为恰好使用\(i(i=0,1,2,\cdots,k)\)种颜色的方案数, 那么 \[m(m-1)^{n-1}=\sum_{i=0}^m\begin{pmatrix}m\\i\end{pmatrix}f_i \tag{12}\] 经过反演得到 \[f_m=\sum_{i=0}^m(-1)^{m-i}\begin{pmatrix}m\\i\end{pmatrix}g_i \tag{13}\] \(BZOJ2839\):集合计数 记\(b_i\)为交集有至少\(i\)个集合的个数, 枚举\(i\)个交集后, 共有\(2^{n-i}\)个互不相同的集合, 每个集合又有选与不选两种方案, 故\(b_i=\begin{pmatrix}n\\i\end{pmatrix}2^{2^{n-i}}\), 那么我们开始演了 \[b_k=\sum_{i=k}^n\begin{pmatrix}i\\k\end{pmatrix}a_i\quad\Leftrightarrow\quad a_k=\sum_{i=k}^n(-1)^{n-k}\begin{pmatrix}i\\k\end{pmatrix}b_i\] 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;cmath&gt;#include &lt;cctype&gt;using namespace std;#define ll long long#define pii pair&lt;int,int&gt;#define inc(i,l,r) for(int i=l;i&lt;=r;++i)#define dec(i,l,r) for(int i=r;i&gt;=l;--i)#define mem(a,v) memset(a,v,sizeof(a))const int N = 1e6, INF = 0x3f3f3f3f;const ll MOD = 1e9 + 7;template &lt;typename T&gt;void read(T &amp;x)&#123; x = 0; ll f = 1; char ch = getchar(); while (!isdigit(ch)) &#123;if(ch == '-') f = -1; ch = getchar();&#125; while (isdigit(ch)) x = (x&lt;&lt;3) + (x&lt;&lt;1) + ch - '0', ch = getchar(); x *= f;&#125;ll n, k, ans;ll fac[N], inv[N], p[N];ll power(ll a, ll b)&#123; ll res = 1; for (; b; a = a * a % MOD, b &gt;&gt;= 1) if (b &amp; 1) res = res * a % MOD; return res;&#125;ll C(ll n, ll m)&#123; return fac[n] * inv[m] % MOD * inv[n-m] % MOD;&#125;int main()&#123; read(n), read(k); fac[0] = inv[0] = p[0] = 1; inc(i,1,n) fac[i] = (ll)fac[i-1] * i % MOD, p[i] = (ll)p[i-1] * 2 % (MOD - 1); inv[n] = power(fac[n], MOD - 2); dec(i,1,n-1) inv[i] = (ll)inv[i+1] * (i + 1) % MOD; inc(i,k,n) &#123; (ans += MOD + ((i-k) &amp; 1 ? -1 : 1) * (C(i,k) * C(n,i) % MOD * (power(2, p[n-i]) % MOD))) %= MOD; &#125; printf("%lld\n", ans); return 0;&#125; 斯特林反演 在这里, 先回顾一下斯特林数(\(dalao\)请自动忽略) 第一类斯特林数 定义: 将\(n\)个元素排成\(m\)个轮换的方法数 从\(n-1\)的情况推过来, 要么将最后一个元素放进自身的轮换, 要么将最后一个元素放进前\(n-1\)个元素分成的\(\begin{bmatrix}n-1\\m\end{bmatrix}\)个轮换中的一个, 可以得到: \[\begin{bmatrix}n\\m\end{bmatrix}=\begin{bmatrix}n-1\\m-1\end{bmatrix}+(n-1)*\begin{bmatrix}n-1\\m\end{bmatrix} \tag{14}\] 由于\(\begin{bmatrix}n\\ k\end{bmatrix}\)是\(n\)个元素恰好包含\(k\)个轮换的排列个数, 对所有的\(k\)求和, 必然得到排列的总数 \[\sum_{k=0}^n\begin{bmatrix}n\\ k\end{bmatrix}=n! \tag{15}\] 下面是与下降幂\(x^{\underline{n}}\)和阶乘幂\(x^{\overline{n}}\)的关系 \[x^{\underline{n}}=\sum_{i=0}^n\begin{bmatrix}n\\i\end{bmatrix}(-1)^{n-i}x^i \tag{16}\] 用归纳法证明 \[\begin{array}{l} x^{\underline{n+1}}&amp;=&amp;(x-n)x^{\underline{n}}\\ &amp;=&amp;(x-n)\displaystyle\sum_{i=0}^n\begin{bmatrix}n\\i\end{bmatrix}(-1)^{n-i}x^i\\ &amp;=&amp;\displaystyle\sum_{i=0}^n\begin{bmatrix}n\\i\end{bmatrix}(-1)^{n-i}x^{i+1}-n\sum_{i=0}^{n+1}\begin{bmatrix}n\\i\end{bmatrix}(-1)^{n-i}x^i\\ &amp;=&amp;\displaystyle\sum_{i=1}^{n+1}\begin{bmatrix}n\\i-1\end{bmatrix}(-1)^{n-i+1}x^{i}+n\sum_{i=0}^{n+1}\begin{bmatrix}n\\i\end{bmatrix}(-1)^{n-i+1}x^i\\ &amp;=&amp;\displaystyle\sum_{i=0}^{n+1}\left(\begin{bmatrix}n\\i-1\end{bmatrix}+n\begin{bmatrix}n\\i\end{bmatrix}\right)(-1)^{n-i+1}x^i\\ &amp;=&amp;\displaystyle\sum_{i=0}^{n+1}\begin{bmatrix}n+1\\i\end{bmatrix}(-1)^{n+1-i}x^i \end{array}\] 类似可以证明 \[x^{\overline{n}}=\sum_{i=0}^n\begin{bmatrix}n\\i\end{bmatrix}x^i \tag{17}\] 第二类斯特林数 定义: 将一个有\(n\)件物品的集合划分成\(m\)个非空子集的方法数 从\(n-1\)的情况推过来, 要么将最后一个元素单独放一类, 要么与前\(n-1\)个元素的某个非空子集放一起, 可以得到: \[\begin{Bmatrix}n\\m\end{Bmatrix}=\begin{Bmatrix}n-1\\m-1\end{Bmatrix}+m*\begin{Bmatrix}n-1\\m\end{Bmatrix} \tag{18}\] 下面是与下降幂\(x^{\underline{n}}\)和阶乘幂\(x^{\overline{n}}\)的关系 \[m^n=\sum_{i=0}^n\begin{Bmatrix}n\\i\end{Bmatrix}m^{\underline{i}} \tag{19}\] 用归纳法证明, 由于\(x*x^{\underline{i}}=x^{\underline{i+1}}+ix^{\underline{i}}\) \[\begin{array}{l} m^{n+1}&amp;=&amp;m\displaystyle\sum_{i=0}^n\begin{Bmatrix}n\\i\end{Bmatrix}m^{\underline{i}}\\ &amp;=&amp;\displaystyle\sum_{i=0}^n\begin{Bmatrix}n\\i\end{Bmatrix}m^{\underline{i+1}}+\sum_{i=0}^n\begin{Bmatrix}n\\i\end{Bmatrix}im^{\underline{i}}\\ &amp;=&amp;\displaystyle\sum_{i=1}^{n+1}\begin{Bmatrix}n\\i-1\end{Bmatrix}m^{\underline{i}}+\sum_{i=0}^{n+1}\begin{Bmatrix}n\\i\end{Bmatrix}im^{\underline{i}}\\ &amp;=&amp;\displaystyle\sum_{i=0}^{n+1}\left(\begin{Bmatrix}n\\i-1\end{Bmatrix}+i\begin{Bmatrix}n\\i\end{Bmatrix}\right)m^{\underline{i}}\\ &amp;=&amp;\displaystyle\sum_{i=0}^{n+1}\begin{Bmatrix}n+1\\i\end{Bmatrix}m^{\underline{i}} \end{array}\] 类似可以证明 \[m^n=\sum_{i=0}^n\begin{Bmatrix}n\\i\end{Bmatrix}(-1)^{n-i}m^{\overline{i}} \tag{20}\] 当然还有两个比较显然的东西 \[x^{\underline{n}}=(-1)(-x)^{\overline{n}} \tag{21}\] \[x^{\overline{n}}=(-1)(-x)^{\underline{n}} \tag{22}\] 反转公式 \[\sum_{k=m}^n(-1)^{n-k}\begin{bmatrix}n\\k\end{bmatrix}\begin{Bmatrix}k\\m\end{Bmatrix}=[m=n] \tag{23}\] \[\sum_{k=m}^n(-1)^{n-k}\begin{Bmatrix}n\\k\end{Bmatrix}\begin{bmatrix}k\\m\end{bmatrix}=[m=n] \tag{24}\] \(proof\ 1:\) \[\begin{array}{l} m^{\underline{n}}&amp;=&amp;\displaystyle\sum_{i=0}^n\begin{bmatrix}n\\i\end{bmatrix}(-1)^{n-i}m^i\\ &amp;=&amp;\displaystyle\sum_{i=0}^n\begin{bmatrix}n\\i\end{bmatrix}(-1)^{n-i}\sum_{j=0}^i\begin{Bmatrix}i\\j\end{Bmatrix}m^{\underline{j}}\\ &amp;=&amp;\displaystyle\sum_{i=0}^nm^{\underline{i}}\sum_{j=i}^n(-1)^{n-j}\begin{bmatrix}n\\j\end{bmatrix}\begin{Bmatrix}j\\i\end{Bmatrix} \end{array}\] \(proof\ 2:\) \[\begin{array}{l} m^n&amp;=&amp;\displaystyle\sum_{i=0}^n\begin{Bmatrix}n\\i\end{Bmatrix}m^{\underline{i}}\\ &amp;=&amp;\displaystyle\sum_{i=0}^n\begin{Bmatrix}n\\i\end{Bmatrix}\sum_{j=0}^i(-1)^{i-j}\begin{bmatrix}i\\j\end{bmatrix}m^j\\ &amp;=&amp;\displaystyle\sum_{i=0}^nm^i\sum_{j=i}^n(-1)^{n-j}\begin{Bmatrix}n\\j\end{Bmatrix}\begin{bmatrix}j\\i\end{bmatrix} \end{array}\] 斯特林反演 \[f(n)=\sum_{i=0}^n\begin{Bmatrix}n\\k\end{Bmatrix}g(k) \quad\Leftrightarrow\quad g(n)=\sum_{k=0}^n(-1)^{n-k}\begin{bmatrix}n\\k\end{bmatrix}f(k) \tag{25}\] \((25)\)的证明如下: \[\begin{array}{l} f(n)&amp;=&amp;\displaystyle\sum_{k=0}^n\begin{Bmatrix}n\\k\end{Bmatrix}g(k)\\ &amp;=&amp;\displaystyle\sum_{k=0}^n\begin{Bmatrix}n\\k\end{Bmatrix}\sum_{j=0}^k(-1)^{k-j}\begin{bmatrix}k\\j\end{bmatrix}f(j)\\ &amp;=&amp;\displaystyle\sum_{k=0}^n\sum_{j=k}^n\begin{Bmatrix}n\\j\end{Bmatrix}\begin{bmatrix}j\\k\end{bmatrix}(-1)^{j-k}f(k)\\ &amp;=&amp;\displaystyle\sum_{k=0}^n[k=n]f(k)\\ &amp;=&amp;f(n) \end{array}\] 莫比乌斯反演 莫比乌斯函数\(\mu(m)\) 对所有整数\(m\geq1由等式\) \[\sum_{d|m}\mu(d)=\left[m=1\right] \tag{26}\] 来定义, 这个等式是一个递归式, 代入\(m=1,2,\cdots,12\)可以得到前\(12\)个值: \(m\) \(1\) \(2\) \(3\) \(4\) \(5\) \(6\) \(7\) \(8\) \(9\) \(10\) \(11\) \(12\) \(\mu(m)\) \(1\) \(-1\) \(-1\) \(0\) \(-1\) \(1\) \(-1\) \(0\) \(0\) \(1\) \(-1\) \(0\) \[g(m)=\sum_{d|m}f(d)\quad\Leftrightarrow\quad f(m)=\sum_{d|m}\mu(\frac{m}{d})g(d) \tag{27}\] \((27)\)的证明如下: \[\begin{array}{l} g(m)&amp;=&amp;\displaystyle\sum_{d|m}f(d)\\ &amp;=&amp;\displaystyle\sum_{d|m}\sum_{k|d}\mu(\frac{d}{k})g(k)\\ &amp;=&amp;\displaystyle\sum_{k|m}g(k)\sum_{d|m,k|d}\mu(\frac{d}{k})\\ &amp;=&amp;\displaystyle\sum_{k|m}g(k)\sum_{d|(m/k)}\mu(d)\\ &amp;=&amp;\displaystyle\sum_{k|m}[m/k=1]g(k)\\ &amp;=&amp;g(m) \end{array}\]]]></content>
      <tags>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM算法模板]]></title>
    <url>%2F2019%2F08%2F24%2FACM%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[基础 排序 归并排序 1234567891011121314void mergesort(int l, int r) &#123; if(l == r) return ; int mid = (l + r) &gt;&gt; 1; mergesort(l, mid); mergesort(mid+1, r); int p = l, q = mid + 1, cnt = l; while(p &lt;= mid &amp;&amp; q &lt;= r)&#123; if(a[p] &lt; a[q]) t[cnt++] = a[p++]; else t[cnt++] = a[q++]; &#125; while(p &lt;= mid) t[cnt++] = a[p++]; while(q &lt;= r) t[cnt++] = a[q++]; for(int i = l; i &lt;= r; ++i) a[i] = t[i];&#125; 数论 欧几里得 123456int gcd(int a, int b) &#123; return !b ? a : gcd(b, a % b);&#125;int lcm(int a, int b) &#123; return a / gcd(a, b) * b;&#125; 扩展欧几里得 在求出\(gcd(a,b)\)的同时求出二元一次不定方程\(ax+by=gcd(a,b)\)的一组整数解 1234567void exgcd(int a, int b, int &amp;x, int &amp;y) &#123; if (!b) x = 1, y = 0; else &#123; exgcd(b, a % b, x, y); y -= a / b * y; &#125;&#125; 欧拉函数 我们知道\(\varphi(n)\)表示小于\(n\)且与\(n\)互素的整数个数, 而\(n\)可分解为\(n=\displaystyle\prod_{i=1}^kp_i^{a_i}\), 根据容斥原理我们有 \[\varphi(n)=\sum_{S\subseteq\left\{p_1,p_2,\cdots,p_k\right\}}(-1)^{|S|}\frac{n}{\displaystyle\prod_{p_i\in S}p_i}\] 展开后可以得到 \[\varphi(n)=n*\prod_{i=1}^k\left(1-\frac{1}{p_i}\right)\] 若\(n\)是素数 , 有\(\varphi(n)=n−1\) 若\(gcd(n,m)=1\), 有\(\varphi(mn)=\varphi(m)\varphi(n)\) 若\(n\)和\(m\)是素数 , 有\(\varphi(nm)=nm−1\) 若\(p\)是素数 , 有\(\varphi(p^q)=p^q−p^{q−1}\) \(\displaystyle\sum_{d|m}\varphi(d)=m\) 123456789101112int phi(int n)&#123; int ans = n; for (int i = 2; i * i &lt;= n; ++i) &#123; if (n % i == 0) &#123; ans -= ans / i; while (n % i == 0) n /= i; &#125; &#125; if (n &gt; 1) ans -= ans / n; return ans; &#125; 数据结构 并查集 123int find(int x) &#123; return f[x] == x ? x : f[x] = find(f[x]);&#125; 提高]]></content>
      <categories>
        <category>ACM</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[TikZ入门]]></title>
    <url>%2F2019%2F08%2F12%2FTikZ%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[在\(LaTex​\)中, 要用\(tikz​\)作图, 首先调用\(tikz​\)宏包和有关的程序库 12\usepackage&#123;tikz&#125;\usetikzlibrary&#123;&lt;list of libraries&gt;&#125; 然后开启\({tikzpicture}\)环境作图, 或者用\(\\ tikz\)开始作图. 各种命令必须以分号结束, 否则报错 命令` 下面是一个(需调用\(pattern\)库) 123456\begin&#123;tikzpicture&#125;\def\wall&#123; \fill [fill=black!50] (1,-.5) rectangle (2,.5); \pattern [pattern=bricks] (1,-.5) rectangle (2,.5); \draw [line width=1pt] (1cm+.5pt,-.5) -- ++(0,1);&#125;\wall\end&#123;tikzpicture&#125; bricks_tikz 创建coordinate对象的句法及其命名 1234\path . . . coordinate[&lt;options&gt;](&lt;name&gt;)at(&lt;coordinate&gt;) . . . ;%将路径中的某个对象设置为 coordinate \coordinate [&lt;options&gt;](&lt;name&gt;)at(&lt;coordinate&gt;);%这是上一句法的简写，注意最好不要在该命令后面用 node 命令。 基本的坐标计算]]></content>
      <categories>
        <category>LaTex</category>
      </categories>
      <tags>
        <tag>LaTex包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ1845 Sumdiv]]></title>
    <url>%2F2019%2F07%2F17%2FPOJ1845%20Sumdiv%2F</url>
    <content type="text"><![CDATA[\(Sumdiv\) 题意: 求\(A^B\)的所有约数之和\(\mod{9901}\left(1\leq A,B \leq5*10^7\right)\) 分析: A分解质因数为\(p_1^{c_1}\times p_2^{c_2}\times\cdots\times p_n^{c_n}\)。那么\(A^B\)表示为\(p_1^{Bc_1}\times p_2^{Bc_2}\times\cdots\times p_n^{Bc_n}\)。\(A^B\)的所有约数表示为集合\(\{p_1^{k_1}\times p_2^{k_2}\times\cdots\times p_n^{k_n}\}\)，其中\(0\leq k_i \leq B\times c_i\left(1\leq i \leq n\right)\) 由乘法分配律, \(A^B\)的所有约数之和为: \[\left(1+p_1+\cdots+p_1^{B*c_1}\right)*\left(1+p_2+\cdots+p_2^{B*c_2}\right)*\cdots\\*\left(1+p_n+\cdots+p_n^{B*c_n}\right)=\prod_{i=1}^n\left(\sum_{j=0}^{B*c_i}\left(p_i\right)^j\right)\] 括号内为等比数列，直接使用求和公式，需要做除法。答案还需对9901取模，mod运算只对加、减、乘有分配律，不能对分子分母取模后做除法，换一种思路，用分治法对等比数列求和。 用分治法求\(\displaystyle\sum_{i=1}^cp^i\quad\text{若c为奇数:}\) \[\sum_{i=1}^cp^i=\left(1+p+\cdots+p^\frac{c-1}{2}\right)+\left(p^\frac{c+1}{2}+\cdots+p^c\right)\\=\left(1+p+\cdots+p^\frac{c-1}{2}\right)+p^\frac{c+1}{2}*\left(1+p+\cdots+p^\frac{c-1}{2}\right)\\=(1+p^\frac{c+1}{2})*\sum_{i=1}^\frac{c+1}{2}p^i\] 若c为偶数，类似有: \[\sum_{i=1}^cp^i=(1+p^\frac{c}{2})*\sum_{i=1}^{\frac{c}{2}-1}p^i+p^c\] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;#define ll long longconst ll N = 1005, MOD = 9901;pair&lt;ll, ll&gt; fac[N];ll cnt = 0;ll qpow(ll a, ll b)&#123; ll res = 1; for (; b; b &gt;&gt;= 1, a = a * a % MOD) if (b &amp; 1) res = res * a % MOD; return res;&#125;ll sum(ll p, ll c)&#123; if (!c) return 1; if (c &amp; 1) return (qpow(p, (c + 1) / 2) + 1) * sum(p, c / 2) % MOD; return ((qpow(p, c / 2) + 1) * sum(p, c / 2 - 1) + qpow(p, c)) % MOD;&#125;void divide(ll n)&#123; for (ll i = 2; i * i &lt;= n; ++i) &#123; if (n % i == 0) &#123; ll num = 0; while (n % i == 0) &#123; num++; n /= i; &#125; fac[++cnt] = make_pair(i, num); &#125; &#125; if (n &gt; 1) fac[++cnt] = make_pair(n, 1);&#125;int main()&#123; ll a, b; scanf("%lld%lld", &amp;a, &amp;b); divide(a); ll ans = 1; for (ll i = 1; i &lt;= cnt; ++i) &#123; ll p = fac[i].first, c = fac[i].second; ans = ans * sum(p, b * c) % MOD; &#125; printf("%lld\n", a == 0 ? 0 : ans); return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>基础-分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python简易网络爬虫]]></title>
    <url>%2F2019%2F04%2F27%2FPython%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[上大学后自学了点爬虫, 下面是我个人的学习总结 正则表达式 基本概念 正则表达式(regular expression)，又称规则表达式。正则表达式通常被用来检索、替换那些符合某个模式(规则)的文本。 正则表达式的语法 正则表达式语法由字符和操作符构成 正则表达式的常用操作符 操作符 说明 实例 . 表示任何单个字符 [ ] 字符集, 对单个字符给出取值范围 [abc]表示a、b、c, [a-z]表示a到z单个字符 [^ ] 非字符集, 对单个字符给出排除范围 [^abc]表示非a或b或c的单个字符 * 前一个字符0次或无限次扩展 abc*表示ab、abc、abcc、abccc等 + 前一个字符1次或无限次扩展 abc+表示abc、abcc、abccc等 ? 前一个字符0次或1次扩展 abc?表示ab、abc | 左右表达式任意一个 abc|def表示abc、def {m} 扩展前一个字符m次 ab{2}c表示abbc {m,n} 扩展前一个字符m至n次(含n) ab{1,2}表示abc、abbc ^ 匹配字符串开头 ^abc表示abc且在一个字符串的开头 $ 匹配字符串结尾 abc&amp;表示abc且在一个字符串的结尾 ( ) 分组标记, 内部只能使用|操作符 (abc)表示abc、(abc|def)表示abc、def \d 数字, 等价于[0-9] \D 非数字字符, 等价于[^0-9] \w 单词字符(包括下划线), 等价于[A-Za-z0-9_] \W 非单词字符, 等价于[^A-Za-z0-9_] \s 空白字符, 等价于[\f\n\r\t\v] \S 非空白字符, 等价于[^\f\n\r\t\v] Re库默认采用贪婪匹配, 即输出匹配最长的子串 最小匹配操作符 操作符 说明 *? 前1个字符0次或无限次扩展 +? 前1个字符1次或无限次扩展 ?? 前1个字符0次或1次扩展 {m,n}? 扩展前1个字符m次至n次 始位置匹配一个模式，如果不是起始位置匹配成功的话，match()就返回none。 表达式 意义 ^[A-Za-z]+$ 由26个字母组成的字符串 ^[A-Za-z0-9]+$ 由26个字母和数字组成的字符串 ^-?\d+$ 整数形式的字符串 ^[0-9]\*[1-9][0-9]*$ 正整数形式的字符串 [1-9]\d{5} 中国境内邮政编码, 6位 [\u4e00-\u9fa5] 匹配中文字符 \d{3}-\d{8}|\d{4}-\d{7} 国内电话号码, 010-68913536 (([1-9]?\d|1\d{2}|2[0-4]\d|25[0-5]).){3}(([1-9]?\d|1\d{2}|2[0-4]\d|25[0-5])) 匹配IP地址 Re库的基本使用 raw string类型, 是不包含对转义符再次转义的字符串: r'text' re.search(pattern, string, flags=0) 从字符串的起始位置匹配, 如果不是起始位置匹配成功的话, match()就返回none pattern: 正则表达式的字符串或原生字符串表示 string: 待匹配字符串 flags: 正则表达式使用时的控制标记 修饰符 说明 re.I(re.IGNORECASE) 使匹配对大小写不敏感 re.M(re.MULTILINE) 多行匹配, 正则表达式的^操作符能将给定字符串的每行当作匹配开始 re.S(re.DOTALL) 正则表达式的.操作符能够匹配所有字符串, 默认匹配除换行外的所有字符 123456&gt;&gt;&gt; import re&gt;&gt;&gt; match = re.search(r'[1-9]\d&#123;5&#125;', 'Hunanyz 425000')&gt;&gt;&gt; if match: print(match.group(0))425000 12345678910111213#!/usr/bin/python3import reline = "Cats are smarter than dogs";searchObj = re.search( r'(.*) are (.*?) .*', line, re.M|re.I)if searchObj: print ("searchObj.group() : ", searchObj.group())#searchObj.group() : Cats are smarter than dogs print ("searchObj.group(1) : ", searchObj.group(1))#searchObj.group(1) : Cats print ("searchObj.group(2) : ", searchObj.group(2))#searchObj.group(2) : smarterelse: print ("Nothing found!!") re.match(pattern, string, flags=0) re.match 从第一个字符串的开始位置起匹配正则表达式, 返回match对象 group(num=0): 匹配的整个表达式的字符串，group() 可以一次输入多个组号，在这种情况下它将返回一个包含那些组所对应值的元组。 groups(): 返回一个包含所有小组字符串的元组，从 1 到 所含的小组号。 12345678910111213141516&gt;&gt;&gt; import re&gt;&gt;&gt; match = re.match(r'[1-9]\d&#123;5&#125;', 'Hunanyz 425000')&gt;&gt;&gt; if match: match.group(0) &gt;&gt;&gt; match.group(0)Traceback (most recent call last): File "&lt;pyshell#15&gt;", line 1, in &lt;module&gt; match.group(0)AttributeError: 'NoneType' object has no attribute 'group'&gt;&gt;&gt; match = re.match(r'[1-9]\d&#123;5&#125;', '425000 Hunanyz')&gt;&gt;&gt; if match: match.group(0)'425000' 函数式用法: 一次性操作 1&gt;&gt;&gt; rst = re.search(r'[1-9]\d&#123;5&#125;', 'Hunanyz 425000') 面向对象用法: 编译后的多次操作 12&gt;&gt;&gt; pat = re.compile(r'[1-9]\d&#123;5&#125;')&gt;&gt;&gt; rst = pat.search('Hunanyz 425000') re.findall(pattern, string, flags=0) 123&gt;&gt;&gt; import re&gt;&gt;&gt; re.findall(r'[1-9]\d&#123;5&#125;','Hunanyz425000 ywt666666')['425000', '666666'] re.split(pattern, string, maxsplit=0, flags=0) 12345&gt;&gt;&gt; import re&gt;&gt;&gt; re.split(r'[1-9]\d&#123;5&#125;','Hunanyz425000 ywt666666')['Hunanyz', ' ywt', '']&gt;&gt;&gt; re.split(r'[1-9]\d&#123;5&#125;','Hunanyz425000 ywt666666', maxsplit=1)['Hunanyz', ' ywt666666'] re.finditer(pattern, string, flags=0) 1234567&gt;&gt;&gt; import re&gt;&gt;&gt; for m in re.finditer(r'[1-9]\d&#123;5&#125;', 'Hunanyz425000 ywt666666'): if m: print(m.group(0)) 425000666666 re.sub(pattern, repl, string, count=0, flags=0) 123&gt;&gt;&gt; import re&gt;&gt;&gt; re.sub(r'[1-9]\d&#123;5&#125;', ':zipcode','Hunanyz425000 ywt666666')'Hunanyz:zipcode ywt:zipcode' 可以在https://regex101.com/进行练习 简单应用举例 淘宝商品比价定向爬虫 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#CrawTaobaoPrice.pyimport requestsimport re def getHTMLText(url): try: cookies = &#123;&#125; cookiestext = 'miid=447214471620210220; t=daacc1adb7b8d8ce463fc06d0450c7ce; _m_h5_tk=002873f26cfc1e420ff3122c5492c7c9_1557484529238; _m_h5_tk_enc=65acce1ae24f182e94781af0151760a8; cna=eEfQE0Z7LH0CAXFJnusRzYTI; thw=cn; v=0; cookie2=1daeaf566f932421be0293c558854e53; _tb_token_=e4714b1e4b700; skt=fe7483af86fc3fa7; csg=c58e3cb2; uc3=vt3=F8dBy3qLpz1EFG7igHg%3D&amp;id2=Uone%2BIX5BNoxeA%3D%3D&amp;nk2=F5RMHlysDcyBUg%3D%3D&amp;lg2=VFC%2FuZ9ayeYq2g%3D%3D; existShop=MTU1NzQ3NDQ5MA%3D%3D; tracknick=tb97668932; lgc=tb97668932; _cc_=W5iHLLyFfA%3D%3D; dnk=tb97668932; tg=0; enc=3ukH3QlCeyiQ6MFTauMNgLvWKWnuXa3Jw3n2WhkpKJAmlq33XogQu8U1mIK3erlfcBDcFlwD%2B0PqC6mRrGzvUQ%3D%3D; mt=ci=110_1; hng=CN%7Czh-CN%7CCNY%7C156; x=e%3D1%26p%3D*%26s%3D0%26c%3D0%26f%3D0%26g%3D0%26t%3D0; swfstore=213919; uc1=cookie15=U%2BGCWk%2F75gdr5Q%3D%3D&amp;cookie14=UoTZ48F1Orvnkg%3D%3D; alitrackid=www.taobao.com; lastalitrackid=www.taobao.com; JSESSIONID=779A7AFFB8D472B89FE1153556AA5258; l=bBxX6XbVv0FzD8MSBOCg5uI8aPbOSLAAIuPRwNcXi_5N-6L6Vd_OlL6deFp6Vj5RO6TB4XEDz5w9-etui; isg=BGRk0tuo5AKzCBDOAudCpWpJIGKWVYgCO075jX6F8C_yKQTzpg1Y95oL6cGU0MC_' kv = &#123;'user-agent': 'Mozilla/5.0'&#125; for line in cookiestext.split(';'): name,value = line.strip().split('=',1) cookies[name] = value r = requests.get(url,headers = kv, cookies=cookies, timeout=30) r.raise_for_status() r.encoding = r.apparent_encoding return r.text except: return ""def parsePage(ilt, html): plt = re.findall(r'\"view_price\"\:\"[\d\.]*\"',html) tlt = re.findall(r'\"raw_title\"\:\".*?\"',html) for i in range(len(plt)): price = eval(plt[i].split(':')[1]) title = eval(tlt[i].split(':')[1]) ilt.append([price, title])def printGoodsList(ilt): tplt = "&#123;:4&#125;\t&#123;:8&#125;\t&#123;:16&#125;" print(tplt.format("序号", "价格", "商品名称")) count = 0 for g in ilt: count = count + 1 print(tplt.format(count, g[0], g[1])) def main(): goods = '书包' depth = 3 start_url = 'https://s.taobao.com/search?q=' + goods infoList = [] for i in range(depth): try: url = start_url + '&amp;s=' + str(44*i) html = getHTMLText(url) parsePage(infoList, html) except: continue printGoodsList(infoList)main() 关于淘宝反爬的解决 关于爬虫的深入学习将在后续发布]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[部分写作知识点小结]]></title>
    <url>%2F2019%2F01%2F03%2F%E5%8D%9A%E5%AE%A2%E5%86%99%E4%BD%9C%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[本文将主要介绍一些关于博客写作的小知识点(防遗忘) 水的一篇好文 Markdown Markdown教程现在已经烂大街了，在这里主要是作为备忘录进行查阅。 公式 插入公式与代码分别是用$与 ` 符号(～键)包裹所写部分 在需要高亮的代码块的前一行及后一行使用三个反引号。 同时第一行反引号后面，写代码块所使用的语言。 使用 \left和 \right来创建自动匹配高度的 ()，[] 和 {} 。 在每个公式末尾前使用\tag{行标}来实现行标。 希腊字母 显示 大写 命令 显示 大写 命令 \(\alpha\) \(\rm{A}\) $\alpha$ \(\beta\) \(\rm{B}\) $\beta$ \(\gamma\) \(\Gamma\) $\gamma$ \(\delta\) \(\Delta\) $\delta$ \(\epsilon\) \(\rm{E}\) $\epsilon$ \(\zeta\) \(\rm{Z}\) $\zeta$ \(\eta\) \(\rm{H}\) $\eta$ \(\theta\) \(\Theta\) $\theta$ \(\iota\) \(\rm{I}\) $\iota$ \(\kappa\) \(\rm{K}\) $\kappa$ \(\lambda\) \(\Lambda\) $\lambda$ \(\mu\) \(\rm{M}\) $\mu$ \(\nu\) \(\rm{N}\) $\nu$ \(\xi\) \(\Xi\) $\xi$ \(\pi\) \(\Pi\) $\pi$ \(\rho\) \(\rm{R}\) $\rho$ \(\sigma\) \(\Sigma\) $\sigma$ \(\tau\) \(\rm{T}\) $\tau$ \(\upsilon\) \(\Upsilon\) $\upsilon$ \(\phi\) \(\Phi\) $\phi$ \(\chi\) \(\rm{X}\) $\chi$ \(\psi\) \(\Psi\) $\psi$ \(\omega\) \(\Omega\) $\omega$ :只需将命令的首字母大写即可得大写希腊字母，在命令前加上var前缀即可得到斜体希腊字母如: \(\Gamma\phi\) &amp; \(\varGamma\varphi​\) 1$\Gamma\phi$ &amp; $\varGamma\varphi​$ 运算 命令 显示 命令 显示 $\pm$ \(\pm\) $\mp$ \(\mp\) $\neq$ \(\neq\) $\times$ \(\times\) $\div$ \(\div\) $\leq$ \(\leq\) $\geq$ \(\geq\) $\ngeq$ \(\ngeq\) $\ast$ \(\ast\) $\approx$ \(\approx\) $\equiv$ \(\equiv\) $bigcup$ \(\bigcup\) $\iint$ \(\iint\) $\iiint$ \(\iiint\) $\oint$ \(\oint\) $\mid$ \(\mid\) $\because$ \(\because\) \therefore \(\therefore\) 特殊符号 显示 命令 显示 命令 \(\infty\) $\infty$ \(\cup\) $\cup$ \(\cap\) $\cap$ \(\subset\) $\subset$ \(\subseteq\) $\subseteq$ \(\supset\) $\supset$ \(\in\) $\in$ \(\notin\) $\notin$ \(\varnothing\) $\varnothing$ \(\forall\) $\forall$ \(\exists\) $\exists$ \(\lnot\) $\lnot$ \(\nabla\) $\nabla$ \(\partial\) $\partial$ \(\angle\) $\angle$ \(\bot\) $\bot$ \(\bigodot\) $\bigodot$ \(\bigotimes\) $\bigotimes$ 空格 $\,$ \(\frac{1}{6}\)m宽度 $\;$ \(\frac{2}{7}\)m宽度 $\$ \(\frac{1}{3}\)m宽度 $\quad$ m宽度 $\qquad$ 2m宽度 表情 syntax preview syntax preview :sun_with_face: 🌞 :smile: 😄 :laughing: 😆 :blush: 😊 :smiley: 😃 :relaxed: ☺️ :smirk: 😏 :heart_eyes: 😍 :kissing_heart: 😘 :kissing_closed_eyes: 😚 :flushed: 😳 :relieved: 😌 :satisfied: 😆 :grin: 😁 :wink: 😉 :stuck_out_tongue_winking_eye: 😜 :stuck_out_tongue_closed_eyes: 😝 :grinning: 😀 :kissing: 😗 :kissing_smiling_eyes: 😙 :stuck_out_tongue: 😛 :sleeping: 😴 :worried: 😟 :frowning: 😦 :anguished: 😧 :open_mouth: 😮 :confused: 😕 :hushed: 😯 :expressionless: 😑 :unamused: 😒 :sweat_smile: 😅 :sweat: 😓 矢量与箭头 命令 显示 命令 显示 $\vec{a}$ \(\vec{a}\) $\bar{s}$ \(\bar{s}\) (平均值) $\rightarrow$ \(\rightarrow\) $\Rightarrow$ \(\Rightarrow\) $\overrightarrow{a}$ \(\overrightarrow{a}\) $\overleftrightarrow{a}$ \(\overleftrightarrow{a}\) $\overleftarrow{a}$ \(\overleftarrow{a}\) $\longrightarrow$ \(\longrightarrow\) $\overline{a+b}$ \(\overline{a+b}\) $\underline{a+b}$ \(\underline{a+b}\) $\overbrace{a+\underbrace{b+c}_{1.0}+d}^{2.0}$ \(\overbrace{a+\underbrace{b+c}_{1.0}+d}^{2.0}\) $\hat{y}$ \(\hat{y}\) 矩阵与方程组 pmatrix: $\begin{pmatrix}1 &amp; 2 \\ 3 &amp; 4\\ \end{pmatrix}$ : \[\begin{pmatrix}1 &amp; 2 \\ 3 &amp; 4\\ \end{pmatrix}\] bmatrix: $\begin{bmatrix}1 &amp; 2 \\ 3 &amp; 4\\ \end{bmatrix}$ : \[\begin{bmatrix}1 &amp; 2 \\ 3 &amp; 4\\ \end{bmatrix}\] Bmatrix: $\begin{Bmatrix}1 &amp; 2 \\ 3 &amp; 4\\ \end{Bmatrix}$ : \[\begin{Bmatrix}1 &amp; 2 \\ 3 &amp; 4\\ \end{Bmatrix}\] vmatrix: $\begin{vmatrix}1 &amp; 2 \\ 3 &amp; 4\\ \end{vmatrix}$ : \[\begin{vmatrix}1 &amp; 2 \\ 3 &amp; 4\\ \end{vmatrix}\] Vmatrix: $\begin{Vmatrix}1 &amp; 2 \\ 3 &amp; 4\\ \end{Vmatrix}$ : \[\begin{Vmatrix}1 &amp; 2 \\ 3 &amp; 4\\ \end{Vmatrix}\] 12345678910111213141516171819$$\begin&#123;matrix&#125;a_&#123;11&#125;&amp;a_&#123;12&#125;&amp;\cdots&amp;a_&#123;1n&#125;\\a_&#123;21&#125;&amp;a_&#123;21&#125;&amp;\cdots&amp;a_&#123;2n&#125;\\\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\a_&#123;n1&#125;&amp;a_&#123;n2&#125;&amp;\cdots&amp;a_&#123;nn&#125;\\\end&#123;matrix&#125;$$(类似有\ldots底端对齐)$$\left\&#123;\begin&#123;array&#125;\a_1x + a_2y + a_3z = d_1 \\b_1x + b_2y + b_3z = d_2 \\\end&#123;array&#125;\right.$$(array亦可改为cases)$$\begin&#123;cases&#125; a_&#123;11&#125;x_1&amp;+&amp;a_&#123;12&#125;x_2&amp;+&amp;\cdots&amp;+a_&#123;1n&#125;x_n&amp;=&amp;b_1\\ &amp;&amp;&amp;&amp;\vdots\\ a_&#123;n1&#125;x_1&amp;+&amp;a_&#123;n2&#125;x_2&amp;+&amp;\cdots&amp;+a_&#123;nn&#125;x_n&amp;=&amp;b_n&amp; \end&#123;cases&#125;$$ \[\begin{matrix}a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1n}\\\ \ a_{21}&amp;a_{21}&amp;\cdots&amp;a_{2n}\\\ \ \vdots &amp; \vdots &amp; \ddots &amp; \vdots\\\ \ a_{n1} &amp; a_{n2} &amp; \cdots &amp; a_{nn}\\\ \end{matrix}\] \[\begin{cases} ​ a_{11}x_1&amp;+&amp;a_{12}x_2&amp;+&amp;\cdots&amp;+a_{1n}x_n&amp;=&amp;b_1\\\ &amp;&amp;&amp;&amp;\vdots\\\ a_{n1}x_1&amp;+&amp;a_{n2}x_2&amp;+&amp;\cdots&amp;+a_{nn}x_n&amp;=&amp;b_n&amp; \end{cases}\] 字体 输入 说明 实例 输入 说明 实例 $\rm{D}$ 罗马体 \(\rm{D}\) $\cal{D}$ 花体 \(\cal{D}\) $\it{D}$ 意大利体 \(\it{D}\) $\Bbb{D}$ 黑板粗体 \(\Bbb{D}\) $\bf{D}$ 粗体 \(\bf{D}\) $\mit{D}$ 数学斜体 \(\mit{D}\) $\sf{D}$ 等线体 \(\sf{D}\) $\scr{D}$ 手写体 \(\scr{D}\) $\tt{D}$ 打字机体 \(\tt{D}\) $\boldsymbol{D}$ 黑体 \(\boldsymbol{D}\) 标题 123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 字体 1234**加粗文字** 对应 &lt;b&gt;加粗文字&lt;/b&gt; 及 &lt;strong&gt;加粗文字&lt;/strong&gt;*倾斜文字* 对应 &lt;i&gt;倾斜文字&lt;/i&gt; 及 &lt;em&gt;倾斜文字&lt;/em&gt;***斜体加粗文字*** ~~加删除线文字~~ 对应 &lt;del&gt;加删除线文字&lt;/del&gt; 引用 多个&gt;用于逐层嵌套 12&gt;引用内容&gt;&gt;引用内容 分割线 三个或者三个以上的 - 或者 *,效果一样 12---*** 图片或链接 1234567![图片说明](图片地址 ''title'')[超链接名](超链接地址 "title")title可加可不加如:[百度](http://www.baidu.com)&lt;a href="http://www.baidu.com"&gt;百度&lt;/a&gt;![风景](https://upload-images.jianshu.io/upload_images/703764-605e3cc2ecb664f6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) 百度 列表 无序列表使用*或+或-标识 有序列表使用数字加.标识，例如：1. 表格 短斜杠(数量至少有一个)左右的冒号用于控制对齐方式，只放置左边冒号表示文字居左，只放置右边冒号表示文字居右，如果两边都放置冒号表示文字居中。 1234表头|条目一|条目二:-:|:-:|:-:1|2|34|5|6 表头 条目一 条目二 1 2 3 4 5 6 pandoc版markdown与标准版的区别 标准Markdown语法并不要求在标题前添加一个空行，但是Pandoc语法却要求标题前添加一个空行（除了文档开头） Html 基本文档 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;文档标题&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 可见文本... &lt;/body&gt; &lt;p&gt;这是一个段落。&lt;/p&gt; &lt;br&gt; （换行）&lt;/html&gt; 基本元素 粗体文粗体文本 int exgcd(int x, int y, int &amp;a, int &amp;b) { if (y == 0) { return a = 1, b = 0, x; } else { int g = exgcd(y, x % y, b, a); b -= x / y * a; return g; } } 强调文本 斜体文本 键盘输入 预格式化文本 更小的文本 重要的文本 缩写 联系信息 文字方向 从另一个源引用的部分 工作的名称 删除的文本 插入的文本下标文本上标文本本 1234567891011121314151617181920212223242526&lt;b&gt;粗体文本&lt;/b&gt;&lt;code class=&quot;language-cpp&quot;&gt;int exgcd(int x, int y, int &amp;a, int &amp;b) &#123; if (y == 0) &#123; return a = 1, b = 0, x; &#125; else &#123; int g = exgcd(y, x % y, b, a); b -= x / y * a; return g; &#125;&#125;&lt;/code&gt;&lt;em&gt;强调文本&lt;/em&gt;&lt;i&gt;斜体文本&lt;/i&gt;&lt;kbd&gt;键盘输入&lt;/kbd&gt; &lt;pre&gt;预格式化文本&lt;/pre&gt;&lt;small&gt;更小的文本&lt;/small&gt;&lt;strong&gt;重要的文本&lt;/strong&gt;&lt;abbr&gt;缩写&lt;/abbr&gt;&lt;br&gt;&lt;address&gt;联系信息&lt;/address&gt;&lt;bdo&gt;文字方向&lt;/bdo&gt;&lt;blockquote&gt;从另一个源引用的部分&lt;/blockquote&gt;&lt;cite&gt;工作的名称&lt;/cite&gt; &lt;del&gt;删除的文本&lt;/del&gt; &lt;ins&gt;插入的文本&lt;/ins&gt;&lt;sub&gt;下标文本&lt;/sub&gt;&lt;sup&gt;上标文本&lt;/sup&gt;本&lt;/b&gt; 标题 123456&lt;h1&gt;一级标题&lt;/h1&gt;&lt;h2&gt;二级标题&lt;/h2&gt;&lt;h3&gt;三级标题&lt;/h3&gt;&lt;h4&gt;四级标题&lt;/h4&gt;&lt;h5&gt;五级标题&lt;/h5&gt;&lt;h6&gt;六级标题&lt;/h6&gt; 列表与表格 Coffee Milk Cola sara &lt;dt&gt;Coffee&lt;/dt&gt;&lt;!--自定义列表项目--&gt;&lt;dd&gt;- Black hot drink&lt;/dd&gt;&lt;!--自定义列表项目--&gt; &lt;dt&gt;Milk&lt;/dt&gt;&lt;dd&gt;- White cold drink&lt;/dd&gt; 123456789101112131415161718192021222324&lt;ul&gt;&lt;!--无序列表--&gt; &lt;li&gt;Coffee&lt;/li&gt;&lt;li&gt;Milk&lt;/li&gt;&lt;/ul&gt;&lt;ol&gt;&lt;!--有序列表--&gt; &lt;li&gt;Cola&lt;/li&gt;&lt;li&gt;sara&lt;/li&gt;&lt;/ol&gt;&lt;dl&gt;&lt;!--定义列表--&gt; &lt;dt&gt;Coffee&lt;/dt&gt;&lt;!--自定义列表项目--&gt;&lt;dd&gt;- Black hot drink&lt;/dd&gt;&lt;!--自定义列表项目--&gt; &lt;dt&gt;Milk&lt;/dt&gt;&lt;dd&gt;- White cold drink&lt;/dd&gt;&lt;/dl&gt;&lt;table border="1"&gt; &lt;tr&gt; &lt;th&gt;Header 1&lt;/th&gt;&lt;th&gt;Header 2&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;row 1, cell 1&lt;/td&gt;&lt;td&gt;row 1, cell 2&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;row 2, cell 1&lt;/td&gt;&lt;td&gt;row 2, cell 2&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 图片 普通的链接：百度 图像链接： 邮件链接： 发送e-mail 书签： 提示部分 跳到提示部分 #### 框架 document.write("Hello World!") 抱歉，你的浏览器不支持 JavaScript! LaTex 作为一个数学迷，在高中就接触过一点LaTex，而LaTex+几何画板排版的内容一直都是非常精美，不过由于条件限制我一直没能去系统学习，因此现在希望进行一些总结。 由于内容较多将在以后的博文中介绍]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>小知识</tag>
      </tags>
  </entry>
</search>
