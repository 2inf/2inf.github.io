<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[POJ1845 Sumdiv]]></title>
    <url>%2F2019%2F07%2F17%2FPOJ1845%20Sumdiv%2F</url>
    <content type="text"><![CDATA[$Sumdiv$ 题意: 求$A^B$的所有约数之和$mod9901\left(1\leq A,B \leq5*10^7\right)$ 分析: A分解质因数为$p_1^{c_1}\times p_2^{c_2}\times\cdots\times p_n^{c_n}$。那么$A^B$表示为$p_1^{Bc_1}\times p_2^{Bc_2}\times\cdots\times p_n^{Bc_n}$。$A^B$的所有约数表示为集合$\{p_1^{k_1}\times p_2^{k_2}\times\cdots\times p_n^{k_n}\}$，其中$0\leq k_i \leq B\times c_i\left(1\leq i \leq n\right)$ 由乘法分配律, $A^B$的所有约数之和为: \left(1+p_1+\cdots+p_1^{B*c_1}\right)*\left(1+p_2+\cdots+p_2^{B*c_2}\right)*\cdots\\*\left(1+p_n+\cdots+p_n^{B*c_n}\right)=\prod_{i=1}^n\left(\sum_{j=0}^{B*c_i}\left(p_i\right)^j\right)括号内为等比数列，直接使用求和公式，需要做除法。答案还需对9901取模，mod运算只对加、减、乘有分配律，不能对分子分母取模后做除法，换一种思路，用分治法对等比数列求和。 用分治法求$\displaystyle\sum_{i=1}^cp^i\quad\text{若c为奇数:}$ \sum_{i=1}^cp^i=\left(1+p+\cdots+p^\frac{c-1}{2}\right)+\left(p^\frac{c+1}{2}+\cdots+p^c\right)\\=\left(1+p+\cdots+p^\frac{c-1}{2}\right)+p^\frac{c+1}{2}*\left(1+p+\cdots+p^\frac{c-1}{2}\right)\\=(1+p^\frac{c+1}{2})*\sum_{i=1}^\frac{c+1}{2}p^i若c为偶数，类似有: \sum_{i=1}^cp^i=(1+p^\frac{c}{2})*\sum_{i=1}^{\frac{c}{2}-1}p^i+p^c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;#define ll long longconst ll N = 1005, MOD = 9901;pair&lt;ll, ll&gt; fac[N];ll cnt = 0;ll qpow(ll a, ll b)&#123; ll res = 1; for (; b; b &gt;&gt;= 1, a = a * a % MOD) if (b &amp; 1) res = res * a % MOD; return res;&#125;ll sum(ll p, ll c)&#123; if (!c) return 1; if (c &amp; 1) return (qpow(p, (c + 1) / 2) + 1) * sum(p, c / 2) % MOD; return ((qpow(p, c / 2) + 1) * sum(p, c / 2 - 1) + qpow(p, c)) % MOD;&#125;void divide(ll n)&#123; for (ll i = 2; i * i &lt;= n; ++i) &#123; if (n % i == 0) &#123; ll num = 0; while (n % i == 0) &#123; num++; n /= i; &#125; fac[++cnt] = make_pair(i, num); &#125; &#125; if (n &gt; 1) fac[++cnt] = make_pair(n, 1);&#125;int main()&#123; ll a, b; scanf("%lld%lld", &amp;a, &amp;b); divide(a); ll ans = 1; for (ll i = 1; i &lt;= cnt; ++i) &#123; ll p = fac[i].first, c = fac[i].second; ans = ans * sum(p, b * c) % MOD; &#125; printf("%lld\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>基础-分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数学分析-极限]]></title>
    <url>%2F2019%2F07%2F12%2F%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90-%E6%9E%81%E9%99%90%2F</url>
    <content type="text"><![CDATA[本章主要提供一些题目复习，但出于节省时间考虑，不附以解答，若需要个别题目解答可联系$qq: 2247389338$ 设数列$\{a_n\}$满足条件$0 &lt; a_1 &lt; 1$和 $a_{n+1}=a_n(1-a_n)\ (n\geq1)$, 证明: $\lim na_n=1$ 若$\displaystyle\lim_{n\to\infty}a_n=\alpha$, $\displaystyle\lim_{n\to\infty}b_n=\beta$, 证明: $\displaystyle\lim_{n\to\infty}\frac{a_1b_n+a_2b_{n-1}+\cdots+a_nb_1}{n}=\alpha\beta$ $(1)\displaystyle\lim_{n\to\infty}\frac{1^k+2^k+\cdots+n^k}{n^{k+1}}=\frac{1}{k+1}\\(2)\displaystyle\lim_{n\to\infty}\left(\frac{1^k+2^k+\cdots+n^k}{n^k}-\frac{n}{k+1}\right)=\frac{1}{2}$ 设$A_n=\sum\limits_{k=1}^{n}\frac{n}{n^2+k^2}$,求$\lim\limits_{n\to\infty}n\left(\frac{\pi}{4}-A_n\right)$.解:令$f(x)=\frac{1}{1+x^2},$因为$A_n=\frac{1}{n}\sum\limits_{i=1}^{n}\frac{1}{1+\frac{i^2}{n^2}},$所以\lim_{n\to\infty}A_n=\int_{0}^{1}f(x)dx=\frac{\pi}{4}记$x_i=\frac{i}{n}$,则$x_i-x_{i-1}=\frac{1}{n},A_n=n\sum\limits_{i=1}^{n}\int_{x_{i-1}}^{x_i}f(x_i)dx.$令J_n=n\left(\frac{\pi}{4}-A_n\right)=n\sum\limits_{i=1}^{n}\int_{x_{i-1}}^{x_i}\left[f(x)-f(x_i)\right]dx,由拉格朗日中值定理，$\exists\xi_i\in(x_{i-1},x_i)$使得J_n=n\left(\frac{\pi}{4}-A_n\right)=n\sum\limits_{i=1}^{n}\int_{x_{i-1}}^{x_i}f'(\xi_i)\left(x-x_i\right)dx.记$m_i,M_i$分别是$f’(x)$在$\left[x_{i-1},x_i\right]$上的最大值和最小值,则$m_i\leq f’(\xi_i)\leq M_i$,积分$\int_{x_{i-1}}^{x_i}f’(\xi_i)\left(x-x_i\right)dx$介于$m_i\int_{x_{i-1}}^{x_i}\left(x-x_i\right)dx,M_i\int_{x_{i-1}}^{x_i}\left(x-x_i\right)dx$之间,由介值定理\exists\eta_i\in\left(x_{i-1},x_i\right),\int_{x_{i-1}}^{x_i}f'(\xi_i)\left(x-x_i\right)dx=-f'(\eta_i)\frac{\left(x_i-x_{i-1}\right)^2}{2}.于是有$J_n=-\frac{n}{2}\sum\limits_{i=1}^{n}f’(\eta_i)\left(x_i-x_{i-1}\right)^2=-\frac{1}{2n}\sum\limits_{i=1}^{n}f’(\eta_i).$从而\lim_{n\to\infty}n\left(\frac{\pi}{4}-A_n\right)=\lim_{n\to\infty}J_n=-\frac{1}{2}\int_{0}^{1}f'(x)dx=-\frac{1}{2}\left[f\left(1\right)-f\left(0\right)\right]=\frac{1}{4}.]]></content>
  </entry>
  <entry>
    <title><![CDATA[Python简易网络爬虫]]></title>
    <url>%2F2019%2F04%2F27%2FPython%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[上大学后自学了点爬虫, 下面是我个人的学习总结 正则表达式基本概念 正则表达式(regular expression)，又称规则表达式。正则表达式通常被用来检索、替换那些符合某个模式(规则)的文本。 正则表达式的语法正则表达式语法由字符和操作符构成 正则表达式的常用操作符 操作符 说明 实例 . 表示任何单个字符 [ ] 字符集, 对单个字符给出取值范围 [abc]表示a、b、c, [a-z]表示a到z单个字符 非字符集, 对单个字符给出排除范围 abc表示非a或b或c的单个字符 * 前一个字符0次或无限次扩展 abc*表示ab、abc、abcc、abccc等 + 前一个字符1次或无限次扩展 abc+表示abc、abcc、abccc等 ? 前一个字符0次或1次扩展 abc?表示ab、abc &#124; 左右表达式任意一个 abc&#124;def表示abc、def {m} 扩展前一个字符m次 ab{2}c表示abbc {m,n} 扩展前一个字符m至n次(含n) ab{1,2}表示abc、abbc ^ 匹配字符串开头 ^abc表示abc且在一个字符串的开头 $ 匹配字符串结尾 abc&amp;表示abc且在一个字符串的结尾 ( ) 分组标记, 内部只能使用&#124;操作符 (abc)表示abc、(abc&#124;def)表示abc、def \d 数字, 等价于[0-9] \D 非数字字符, 等价于0-9 \w 单词字符(包括下划线), 等价于[A-Za-z0-9_] \W 非单词字符, 等价于A-Za-z0-9_ \s 空白字符, 等价于[\f\n\r\t\v] \S 非空白字符, 等价于\f\n\r\t\v Re库默认采用贪婪匹配, 即输出匹配最长的子串 最小匹配操作符 操作符 说明 *? 前1个字符0次或无限次扩展 +? 前1个字符1次或无限次扩展 ?? 前1个字符0次或1次扩展 {m,n}? 扩展前1个字符m次至n次 始位置匹配一个模式，如果不是起始位置匹配成功的话，match()就返回none。 表达式意义 ^[A-Za-z]+$由26个字母组成的字符串 ^[A-Za-z0-9]+$由26个字母和数字组成的字符串 ^-?\d+$整数形式的字符串 ^[0-9]\*[1-9][0-9]*$正整数形式的字符串 [1-9]\d{5}中国境内邮政编码, 6位 [\u4e00-\u9fa5]匹配中文字符 \d{3}-\d{8}|\d{4}-\d{7}国内电话号码, 010-68913536 (([1-9]?\d|1\d{2}|2[0-4]\d|25[0-5]).){3}(([1-9]?\d|1\d{2}|2[0-4]\d|25[0-5]))匹配IP地址 Re库的基本使用 raw string类型, 是不包含对转义符再次转义的字符串: r’text’ re.search(pattern, string, flags=0)从字符串的起始位置匹配, 如果不是起始位置匹配成功的话, match()就返回none pattern: 正则表达式的字符串或原生字符串表示string: 待匹配字符串 flags: 正则表达式使用时的控制标记 修饰符说明 re.I(re.IGNORECASE)使匹配对大小写不敏感 re.M(re.MULTILINE)多行匹配, 正则表达式的^操作符能将给定字符串的每行当作匹配开始 re.S(re.DOTALL)正则表达式的.操作符能够匹配所有字符串, 默认匹配除换行外的所有字符 123456&gt;&gt;&gt; import re&gt;&gt;&gt; match = re.search(r'[1-9]\d&#123;5&#125;', 'Hunanyz 425000')&gt;&gt;&gt; if match: print(match.group(0))425000 12345678910111213#!/usr/bin/python3import reline = "Cats are smarter than dogs";searchObj = re.search( r'(.*) are (.*?) .*', line, re.M|re.I)if searchObj: print ("searchObj.group() : ", searchObj.group())#searchObj.group() : Cats are smarter than dogs print ("searchObj.group(1) : ", searchObj.group(1))#searchObj.group(1) : Cats print ("searchObj.group(2) : ", searchObj.group(2))#searchObj.group(2) : smarterelse: print ("Nothing found!!") re.match(pattern, string, flags=0)re.match 从第一个字符串的开始位置起匹配正则表达式, 返回match对象 group(num=0):匹配的整个表达式的字符串，group() 可以一次输入多个组号，在这种情况下它将返回一个包含那些组所对应值的元组。 groups():返回一个包含所有小组字符串的元组，从 1 到 所含的小组号。 12345678910111213141516&gt;&gt;&gt; import re&gt;&gt;&gt; match = re.match(r'[1-9]\d&#123;5&#125;', 'Hunanyz 425000')&gt;&gt;&gt; if match: match.group(0) &gt;&gt;&gt; match.group(0)Traceback (most recent call last): File "&lt;pyshell#15&gt;", line 1, in &lt;module&gt; match.group(0)AttributeError: 'NoneType' object has no attribute 'group'&gt;&gt;&gt; match = re.match(r'[1-9]\d&#123;5&#125;', '425000 Hunanyz')&gt;&gt;&gt; if match: match.group(0)'425000' 函数式用法: 一次性操作1&gt;&gt;&gt; rst = re.search(r'[1-9]\d&#123;5&#125;', 'Hunanyz 425000') 面向对象用法: 编译后的多次操作12&gt;&gt;&gt; pat = re.compile(r'[1-9]\d&#123;5&#125;')&gt;&gt;&gt; rst = pat.search('Hunanyz 425000') re.findall(pattern, string, flags=0)123&gt;&gt;&gt; import re&gt;&gt;&gt; re.findall(r'[1-9]\d&#123;5&#125;','Hunanyz425000 ywt666666')['425000', '666666'] re.split(pattern, string, maxsplit=0, flags=0)12345&gt;&gt;&gt; import re&gt;&gt;&gt; re.split(r'[1-9]\d&#123;5&#125;','Hunanyz425000 ywt666666')['Hunanyz', ' ywt', '']&gt;&gt;&gt; re.split(r'[1-9]\d&#123;5&#125;','Hunanyz425000 ywt666666', maxsplit=1)['Hunanyz', ' ywt666666'] re.finditer(pattern, string, flags=0)1234567&gt;&gt;&gt; import re&gt;&gt;&gt; for m in re.finditer(r'[1-9]\d&#123;5&#125;', 'Hunanyz425000 ywt666666'): if m: print(m.group(0)) 425000666666 re.sub(pattern, repl, string, count=0, flags=0)123&gt;&gt;&gt; import re&gt;&gt;&gt; re.sub(r'[1-9]\d&#123;5&#125;', ':zipcode','Hunanyz425000 ywt666666')'Hunanyz:zipcode ywt:zipcode' 简单应用举例淘宝商品比价定向爬虫1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#CrawTaobaoPrice.pyimport requestsimport re def getHTMLText(url): try: cookies = &#123;&#125; cookiestext = 'miid=447214471620210220; t=daacc1adb7b8d8ce463fc06d0450c7ce; _m_h5_tk=002873f26cfc1e420ff3122c5492c7c9_1557484529238; _m_h5_tk_enc=65acce1ae24f182e94781af0151760a8; cna=eEfQE0Z7LH0CAXFJnusRzYTI; thw=cn; v=0; cookie2=1daeaf566f932421be0293c558854e53; _tb_token_=e4714b1e4b700; skt=fe7483af86fc3fa7; csg=c58e3cb2; uc3=vt3=F8dBy3qLpz1EFG7igHg%3D&amp;id2=Uone%2BIX5BNoxeA%3D%3D&amp;nk2=F5RMHlysDcyBUg%3D%3D&amp;lg2=VFC%2FuZ9ayeYq2g%3D%3D; existShop=MTU1NzQ3NDQ5MA%3D%3D; tracknick=tb97668932; lgc=tb97668932; _cc_=W5iHLLyFfA%3D%3D; dnk=tb97668932; tg=0; enc=3ukH3QlCeyiQ6MFTauMNgLvWKWnuXa3Jw3n2WhkpKJAmlq33XogQu8U1mIK3erlfcBDcFlwD%2B0PqC6mRrGzvUQ%3D%3D; mt=ci=110_1; hng=CN%7Czh-CN%7CCNY%7C156; x=e%3D1%26p%3D*%26s%3D0%26c%3D0%26f%3D0%26g%3D0%26t%3D0; swfstore=213919; uc1=cookie15=U%2BGCWk%2F75gdr5Q%3D%3D&amp;cookie14=UoTZ48F1Orvnkg%3D%3D; alitrackid=www.taobao.com; lastalitrackid=www.taobao.com; JSESSIONID=779A7AFFB8D472B89FE1153556AA5258; l=bBxX6XbVv0FzD8MSBOCg5uI8aPbOSLAAIuPRwNcXi_5N-6L6Vd_OlL6deFp6Vj5RO6TB4XEDz5w9-etui; isg=BGRk0tuo5AKzCBDOAudCpWpJIGKWVYgCO075jX6F8C_yKQTzpg1Y95oL6cGU0MC_' kv = &#123;'user-agent': 'Mozilla/5.0'&#125; for line in cookiestext.split(';'): name,value = line.strip().split('=',1) cookies[name] = value r = requests.get(url,headers = kv, cookies=cookies, timeout=30) r.raise_for_status() r.encoding = r.apparent_encoding return r.text except: return ""def parsePage(ilt, html): plt = re.findall(r'\"view_price\"\:\"[\d\.]*\"',html) tlt = re.findall(r'\"raw_title\"\:\".*?\"',html) for i in range(len(plt)): price = eval(plt[i].split(':')[1]) title = eval(tlt[i].split(':')[1]) ilt.append([price, title])def printGoodsList(ilt): tplt = "&#123;:4&#125;\t&#123;:8&#125;\t&#123;:16&#125;" print(tplt.format("序号", "价格", "商品名称")) count = 0 for g in ilt: count = count + 1 print(tplt.format(count, g[0], g[1])) def main(): goods = '书包' depth = 3 start_url = 'https://s.taobao.com/search?q=' + goods infoList = [] for i in range(depth): try: url = start_url + '&amp;s=' + str(44*i) html = getHTMLText(url) parsePage(infoList, html) except: continue printGoodsList(infoList)main() 关于淘宝反爬的解决 关于爬虫的深入学习将在后续发布]]></content>
  </entry>
  <entry>
    <title><![CDATA[部分写作知识点小结]]></title>
    <url>%2F2019%2F01%2F03%2F%E5%8D%9A%E5%AE%A2%E5%86%99%E4%BD%9C%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[本文将主要介绍一些关于博客写作的小知识点(防遗忘) 水的一篇好文 MarkdownMarkdown教程现在已经烂大街了，在这里主要是作为备忘录进行查阅。 公式插入公式与代码分别是用$与 ` 符号(～键)包裹所写部分 在需要高亮的代码块的前一行及后一行使用三个反引号。 同时第一行反引号后面，写代码块所使用的语言。 使用 \left和 \right来创建自动匹配高度的 ()，[] 和 {} 。在每个公式末尾前使用\tag{行标}来实现行标。 希腊字母 显示 大写 命令 显示 大写 命令 $\alpha$ $\rm{A}$ \alpha $\beta$ $\rm{B}$ \beta $\gamma$ $\Gamma$ \gamma $\delta$ $\Delta$ \delta $\epsilon$ $\rm{E}$ \epsilon $\zeta$ $\rm{Z}$ \zeta $\eta$ $\rm{H}$ \eta $\theta$ $\Theta$ \theta $\iota$ $\rm{I}$ \iota $\kappa$ $\rm{K}$ \kappa $\lambda$ $\Lambda$ \lambda $\mu$ $\rm{M}$ \mu $\nu$ $\rm{N}$ \nu $\xi$ $\Xi$ \xi $\pi$ $\Pi$ \pi $\rho$ $\rm{R}$ \rho $\sigma$ $\Sigma$ \sigma $\tau$ $\rm{T}$ \tau $\upsilon$ $\Upsilon$ \upsilon $\phi$ $\Phi$ \phi $\chi$ $\rm{X}$ \chi $\psi$ $\Psi$ \psi $\omega$ $\Omega$ \omega \注:只需将命令的首字母大写即可得大写希腊字母，在命令前加上var前缀即可得到斜体希腊字母如: $\Gamma\phi$ &amp; $\varGamma\varphi​$ 1$\Gamma\phi$ &amp; $\varGamma\varphi​$ 运算 命令 显示 命令 显示 \pm $\pm$ \mp $\mp$ \neq $\neq$ \times $\times$ \div $\div$ \leq $\leq$ \geq $\geq$ \ngeq $\ngeq$ \ast $\ast$ \approx $\approx$ \equiv $\equiv$ bigcup $\bigcup$ \iint $\iint$ \iiint $\iiint$ \oint $\oint$ \mid $\mid$ \because $\because$ \therefore $\therefore$ 特殊符号 显示 命令 显示 命令 $\infty$ \infty $\cup$ \cup $\cap$ \cap $\subset$ \subset $\subseteq$ \subseteq $\supset$ \supset $\in$ \in $\notin$ \notin $\varnothing$ \varnothing $\forall$ \forall $\exists$ \exists $\lnot$ \lnot $\nabla$ \nabla $\partial$ \partial $\angle$ \angle $\bot$ \bot $\bigodot$ \bigodot $\bigotimes$ \bigotimes 空格 \, $\frac{1}{6}$m宽度 \; $\frac{2}{7}$m宽度 \ $\frac{1}{3}$m宽度 \quad m宽度 \qquad 2m宽度表情| syntax | preview | syntax | preview || :—: | :——: | :—: | :——: ||:sun_with_face:|🌞|:smile:|😄||:laughing:|😆|:blush:|😊||:smiley:|😃|:relaxed:|☺️||:smirk:|😏|:heart_eyes:|😍||:kissing_heart:|😘|:kissing_closed_eyes:|😚||:flushed:|😳|:relieved:|😌||:satisfied:|😆|:grin:|😁||:wink:|😉|:stuck_out_tongue_winking_eye:|😜||:stuck_out_tongue_closed_eyes:|😝|:grinning:|😀||:kissing:|😗|:kissing_smiling_eyes:|😙||:stuck_out_tongue:|😛|:sleeping:|😴|:worried:|😟|:frowning:|😦||:anguished:|😧|:open_mouth:|😮|:confused:|😕|:hushed:|😯||:expressionless:|😑|:unamused:|😒||:sweat_smile:|😅|:sweat:|😓|矢量与箭头 命令 显示 命令 显示 \vec{a} $\vec{a}$ \bar{s} $\bar{s}$ (平均值) \rightarrow $\rightarrow$ \Rightarrow $\Rightarrow$ \overrightarrow{a} $\overrightarrow{a}$ \overleftrightarrow{a} $\overleftrightarrow{a}$ \overleftarrow{a} $\overleftarrow{a}$ \longrightarrow $\longrightarrow$ \overline{a+b} $\overline{a+b}$ \underline{a+b} $\underline{a+b}$ \overbrace{a+\underbrace{b+c}_{1.0}+d}^{2.0} $\overbrace{a+\underbrace{b+c}_{1.0}+d}^{2.0}$ \hat{y} $\hat{y}$ 矩阵与方程组 pmatrix:\begin{pmatrix}1 & 2 \\ 3 & 4\\ \end{pmatrix} : bmatrix:\begin{bmatrix}1 & 2 \\ 3 & 4\\ \end{bmatrix} : Bmatrix:\begin{Bmatrix}1 & 2 \\ 3 & 4\\ \end{Bmatrix} : vmatrix:\begin{vmatrix}1 & 2 \\ 3 & 4\\ \end{vmatrix} : Vmatrix:\begin{Vmatrix}1 & 2 \\ 3 & 4\\ \end{Vmatrix} : 12345678910111213141516171819$$\begin&#123;matrix&#125;a_&#123;11&#125;&amp;a_&#123;12&#125;&amp;\cdots&amp;a_&#123;1n&#125;\\a_&#123;21&#125;&amp;a_&#123;21&#125;&amp;\cdots&amp;a_&#123;2n&#125;\\\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\a_&#123;n1&#125;&amp;a_&#123;n2&#125;&amp;\cdots&amp;a_&#123;nn&#125;\\\end&#123;matrix&#125;$$(类似有\ldots底端对齐)$$\left\&#123;\begin&#123;array&#125;\a_1x + a_2y + a_3z = d_1 \\b_1x + b_2y + b_3z = d_2 \\\end&#123;array&#125;\right.$$(array亦可改为cases)$$\begin&#123;cases&#125; a_&#123;11&#125;x_1&amp;+&amp;a_&#123;12&#125;x_2&amp;+&amp;\cdots&amp;+a_&#123;1n&#125;x_n&amp;=&amp;b_1\\ &amp;&amp;&amp;&amp;\vdots\\ a_&#123;n1&#125;x_1&amp;+&amp;a_&#123;n2&#125;x_2&amp;+&amp;\cdots&amp;+a_&#123;nn&#125;x_n&amp;=&amp;b_n&amp; \end&#123;cases&#125;$$ \begin{matrix}a_{11} & a_{12} & \cdots & a_{1n}\\\ \ a_{21}&a_{21}&\cdots&a_{2n}\\\ \ \vdots & \vdots & \ddots & \vdots\\\ \ a_{n1} & a_{n2} & \cdots & a_{nn}\\\ \end{matrix}\begin{cases} ​ a_{11}x_1&+&a_{12}x_2&+&\cdots&+a_{1n}x_n&=&b_1\\\ &&&&\vdots\\\ a_{n1}x_1&+&a_{n2}x_2&+&\cdots&+a_{nn}x_n&=&b_n& \end{cases}字体 输入 说明 实例 输入 说明 实例 \rm{D} 罗马体 $\rm{D}$ \cal{D} 花体 $\cal{D}$ \it{D} 意大利体 $\it{D}$ \Bbb{D} 黑板粗体 $\Bbb{D}$ \bf{D} 粗体 $\bf{D}$ \mit{D} 数学斜体 $\mit{D}$ \sf{D} 等线体 $\sf{D}$ \scr{D} 手写体 $\scr{D}$ \tt{D} 打字机体 $\tt{D}$ \boldsymbol{D} 黑体 $\boldsymbol{D}$ 标题123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 字体1234**加粗文字** 对应 &lt;b&gt;加粗文字&lt;/b&gt; 及 &lt;strong&gt;加粗文字&lt;/strong&gt;*倾斜文字* 对应 &lt;i&gt;倾斜文字&lt;/i&gt; 及 &lt;em&gt;倾斜文字&lt;/em&gt;***斜体加粗文字*** ~~加删除线文字~~ 对应 &lt;del&gt;加删除线文字&lt;/del&gt; 引用多个&gt;用于逐层嵌套 12&gt;引用内容&gt;&gt;引用内容 分割线三个或者三个以上的 - 或者 *,效果一样 12---*** 图片或链接1234567![图片说明](图片地址 ''title'')[超链接名](超链接地址 "title")title可加可不加如:[百度](http://www.baidu.com)&lt;a href="http://www.baidu.com"&gt;百度&lt;/a&gt;![风景](https://upload-images.jianshu.io/upload_images/703764-605e3cc2ecb664f6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) 百度 列表 无序列表使用*或+或-标识 有序列表使用数字加.标识，例如：1. 表格短斜杠(数量至少有一个)左右的冒号用于控制对齐方式，只放置左边冒号表示文字居左，只放置右边冒号表示文字居右，如果两边都放置冒号表示文字居中。 1234表头|条目一|条目二:-:|:-:|:-:1|2|34|5|6 表头 条目一 条目二 1 2 3 4 5 6 Html基本文档1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;文档标题&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 可见文本... &lt;/body&gt; &lt;p&gt;这是一个段落。&lt;/p&gt; &lt;br&gt; （换行）&lt;/html&gt; 基本元素粗体文粗体文本int exgcd(int x, int y, int &amp;a, int &amp;b) { if (y == 0) { return a = 1, b = 0, x; } else { int g = exgcd(y, x % y, b, a); b -= x / y * a; return g; }}强调文本斜体文本键盘输入 预格式化文本更小的文本重要的文本缩写 联系信息文字方向 从另一个源引用的部分工作的名称 删除的文本 插入的文本下标文本上标文本本&lt;/b&gt;1234567891011121314151617181920212223242526&lt;b&gt;粗体文本&lt;/b&gt;&lt;code class=&quot;language-cpp&quot;&gt;int exgcd(int x, int y, int &amp;a, int &amp;b) &#123; if (y == 0) &#123; return a = 1, b = 0, x; &#125; else &#123; int g = exgcd(y, x % y, b, a); b -= x / y * a; return g; &#125;&#125;&lt;/code&gt;&lt;em&gt;强调文本&lt;/em&gt;&lt;i&gt;斜体文本&lt;/i&gt;&lt;kbd&gt;键盘输入&lt;/kbd&gt; &lt;pre&gt;预格式化文本&lt;/pre&gt;&lt;small&gt;更小的文本&lt;/small&gt;&lt;strong&gt;重要的文本&lt;/strong&gt;&lt;abbr&gt;缩写&lt;/abbr&gt;&lt;br&gt;&lt;address&gt;联系信息&lt;/address&gt;&lt;bdo&gt;文字方向&lt;/bdo&gt;&lt;blockquote&gt;从另一个源引用的部分&lt;/blockquote&gt;&lt;cite&gt;工作的名称&lt;/cite&gt; &lt;del&gt;删除的文本&lt;/del&gt; &lt;ins&gt;插入的文本&lt;/ins&gt;&lt;sub&gt;下标文本&lt;/sub&gt;&lt;sup&gt;上标文本&lt;/sup&gt;本&lt;/b&gt; 标题123456&lt;h1&gt;一级标题&lt;/h1&gt;&lt;h2&gt;二级标题&lt;/h2&gt;&lt;h3&gt;三级标题&lt;/h3&gt;&lt;h4&gt;四级标题&lt;/h4&gt;&lt;h5&gt;五级标题&lt;/h5&gt;&lt;h6&gt;六级标题&lt;/h6&gt; 列表与表格 CoffeeMilk Colasara Coffee- Black hot drink Milk - White cold drink&lt;/dl&gt;123456789101112131415161718192021&lt;ul&gt;&lt;!--无序列表--&gt; &lt;li&gt;Coffee&lt;/li&gt;&lt;li&gt;Milk&lt;/li&gt;&lt;/ul&gt;&lt;ol&gt;&lt;!--有序列表--&gt; &lt;li&gt;Cola&lt;/li&gt;&lt;li&gt;sara&lt;/li&gt;&lt;/ol&gt;&lt;dl&gt;&lt;!--定义列表--&gt; &lt;dt&gt;Coffee&lt;/dt&gt;&lt;!--自定义列表项目--&gt;&lt;dd&gt;- Black hot drink&lt;/dd&gt;&lt;!--自定义列表项目--&gt; &lt;dt&gt;Milk&lt;/dt&gt;&lt;dd&gt;- White cold drink&lt;/dd&gt;&lt;/dl&gt;&lt;table border="1"&gt; &lt;tr&gt; &lt;th&gt;Header 1&lt;/th&gt;&lt;th&gt;Header 2&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;row 1, cell 1&lt;/td&gt;&lt;td&gt;row 1, cell 2&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;row 2, cell 1&lt;/td&gt;&lt;td&gt;row 2, cell 2&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 图片普通的链接：百度图像链接： 邮件链接： 发送e-mail书签：提示部分跳到提示部分 框架 document.write("Hello World!") 抱歉，你的浏览器不支持 JavaScript! LaTex作为一个数学迷，在高中就接触过一点LaTex，而LaTex+几何画板排版的内容一直都是非常精美，不过由于条件限制我一直没能去系统学习，因此现在希望进行一些总结。 由于内容较多将在以后的博文中介绍]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>小知识</tag>
      </tags>
  </entry>
</search>
