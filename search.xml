<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[beamer模板与参考]]></title>
    <url>%2F2019%2F11%2F14%2Fbeamer%E6%A8%A1%E6%9D%BF%E4%B8%8E%E5%8F%82%E8%80%83%2F</url>
    <content type="text"><![CDATA[beamer似乎适合制作一些学术程度较高的ppt, 但当需要添加一些生动的动画时, 它似乎显得比较乏力 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183\documentclass&#123;beamer&#125;% There are many different themes available for Beamer. A comprehensive% list with examples is given here:% http://deic.uab.es/~iblanes/beamer_gallery/index_by_theme.html% You can uncomment the themes below if you would like to use a different% one:%\usetheme&#123;AnnArbor&#125;%\usetheme&#123;Antibes&#125;%\usetheme&#123;Bergen&#125;%\usetheme&#123;Berkeley&#125;%\usetheme&#123;Berlin&#125;%\usetheme&#123;Boadilla&#125;%\usetheme&#123;boxes&#125;%\usetheme&#123;CambridgeUS&#125;%\usetheme&#123;Copenhagen&#125;\usetheme&#123;Darmstadt&#125;%\usetheme&#123;default&#125;%\usetheme&#123;Frankfurt&#125;%\usetheme&#123;Goettingen&#125;%\usetheme&#123;Hannover&#125;%\usetheme&#123;Ilmenau&#125;%\usetheme&#123;JuanLesPins&#125;%\usetheme&#123;Luebeck&#125;%\usetheme&#123;Madrid&#125;%\usetheme&#123;Malmoe&#125;%\usetheme&#123;Marburg&#125;%\usetheme&#123;Montpellier&#125;%\usetheme&#123;PaloAlto&#125;%\usetheme&#123;Pittsburgh&#125;%\usetheme&#123;Rochester&#125;%\usetheme&#123;Singapore&#125;%\usetheme&#123;Szeged&#125;%\usetheme&#123;Warsaw&#125;\usepackage&#123;ctex&#125;\title&#123;基础动态规划&#125;% A subtitle is optional and this may be deleted\subtitle&#123;&#125;\author&#123;author&#125;% - Give the names in the same order as the appear in the paper.% - Use the \inst&#123;?&#125; command only if the authors have different% affiliation.\institute[] % (optional, but mostly needed)&#123; 西安电子科技大学 \and %\inst&#123;2&#125;% ACM基地&#125;% - Use the \inst command only if there are several affiliations.% - Keep it simple, no one is interested in your street address.\date&#123;\today&#125;% - Either use conference name or its abbreviation.% - Not really informative to the audience, more for people (including% yourself) who are reading the slides online\subject&#123;Theoretical Computer Science&#125;% This is only inserted into the PDF information catalog. Can be left% out. % If you have a file called "university-logo-filename.xxx", where xxx% is a graphic format that can be processed by latex or pdflatex,% resp., then you can add a logo as follows:% \pgfdeclareimage[height=0.5cm]&#123;university-logo&#125;&#123;university-logo-filename&#125;% \logo&#123;\pgfuseimage&#123;university-logo&#125;&#125;% Delete this, if you do not want the table of contents to pop up at% the beginning of each subsection:\AtBeginSubsection[]&#123; \begin&#123;frame&#125;&lt;beamer&gt;&#123;Outline&#125; \tableofcontents[currentsection,currentsubsection] \end&#123;frame&#125;&#125;% Let's get started\begin&#123;document&#125;\begin&#123;frame&#125; \titlepage\end&#123;frame&#125;\begin&#123;frame&#125;&#123;Outline&#125; \tableofcontents % You might wish to add the option [pausesections]\end&#123;frame&#125;% Section and subsections will appear in the presentation overview% and table of contents.\section&#123;First Main Section&#125;\subsection&#123;First Subsection&#125;\begin&#123;frame&#125;&#123;First Slide Title&#125;&#123;Optional Subtitle&#125; \begin&#123;itemize&#125; \item &#123; My first point. &#125; \item &#123; My second point. &#125; \end&#123;itemize&#125;\end&#123;frame&#125;\subsection&#123;Second Subsection&#125;% You can reveal the parts of a slide one at a time% with the \pause command:\begin&#123;frame&#125;&#123;Second Slide Title&#125; \begin&#123;itemize&#125; \item &#123; First item. \pause % The slide will pause after showing the first item &#125; \item &#123; Second item. &#125; % You can also specify when the content should appear % by using &lt;n-&gt;: \item&lt;3-&gt; &#123; Third item. &#125; \item&lt;4-&gt; &#123; Fourth item. &#125; % or you can use the \uncover command to reveal general % content (not just \items): \item&lt;5-&gt; &#123; Fifth item. \uncover&lt;6-&gt;&#123;Extra text in the fifth item.&#125; &#125; \end&#123;itemize&#125;\end&#123;frame&#125;\section&#123;Second Main Section&#125;\subsection&#123;Another Subsection&#125;\begin&#123;frame&#125;&#123;Blocks&#125;\begin&#123;block&#125;&#123;Block Title&#125;You can also highlight sections of your presentation in a block, with it's own title\end&#123;block&#125;\begin&#123;theorem&#125;There are separate environments for theorems, examples, definitions and proofs.\end&#123;theorem&#125;\begin&#123;example&#125;Here is an example of an example block.\end&#123;example&#125;\end&#123;frame&#125;% Placing a * after \section means it will not show in the% outline or table of contents.\section*&#123;Summary&#125;\begin&#123;frame&#125;&#123;Summary&#125; \begin&#123;itemize&#125; \item The \alert&#123;first main message&#125; of your talk in one or two lines. \item The \alert&#123;second main message&#125; of your talk in one or two lines. \item Perhaps a \alert&#123;third message&#125;, but not more than that. \end&#123;itemize&#125; \begin&#123;itemize&#125; \item Outlook \begin&#123;itemize&#125; \item Something you haven't solved. \item Something else you haven't solved. \end&#123;itemize&#125; \end&#123;itemize&#125;\end&#123;frame&#125;% All of the following is optional and typically not needed. \appendix\section&lt;presentation&gt;*&#123;\appendixname&#125;\subsection&lt;presentation&gt;*&#123;For Further Reading&#125;\begin&#123;frame&#125;[allowframebreaks] \frametitle&lt;presentation&gt;&#123;For Further Reading&#125; \begin&#123;thebibliography&#125;&#123;10&#125; \beamertemplatebookbibitems % Start with overview books. \bibitem&#123;Author1990&#125; A.~Author. \newblock &#123;\em Handbook of Everything&#125;. \newblock Some Press, 1990. \beamertemplatearticlebibitems % Followed by interesting articles. Keep the list short. \bibitem&#123;Someone2000&#125; S.~Someone. \newblock On this and that. \newblock &#123;\em Journal of This and That&#125;, 2(1):50--100, 2000. \end&#123;thebibliography&#125;\end&#123;frame&#125;\end&#123;document&#125; 下面是以上代码的效果]]></content>
      <categories>
        <category>LaTex</category>
      </categories>
      <tags>
        <tag>beamer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[BZOJ4755] 扭动的回文串]]></title>
    <url>%2F2019%2F10%2F30%2FBZOJ4755-%E6%89%AD%E5%8A%A8%E7%9A%84%E5%9B%9E%E6%96%87%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[题目链接 题解: [点击显示/隐藏代码] 12]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>Manacher</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅析快速傅里叶变换]]></title>
    <url>%2F2019%2F10%2F12%2F%E6%B5%85%E6%9E%90%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[据说现在打信息竞赛的初中生都会\(FFT(Fast\ Fourier\ Transform)\)了, 但严格而言这应该是信号里的内容, 在\(OI\)里可以快速求卷积, 下个学期专业课也会有, 于是前段日子学了一下, 想以此文回顾一下 快速傅里叶变换 快速傅里叶变换可以认为有\(DFT\)和\(IDFT\)两个部分, 分别在\(O(nlogn)\)的复杂度将系数转换成点值表示并转化回来. \(Cooley-Turkey\)算法 \(Cooley-Turkey\)是FFT中最常见的的算法, 基本思想由\(J.W.Cooley\)和\(J.W.Tukey\)在\(1965\)年提出, 是一个基于分治策略的算法, 假设现在有一个\(n-1\)次多项式\(A(x) = \displaystyle\sum_{i=0}^{n-1}a_ix^i\), 为方便叙述, 假设\(n=2^m,m\in\mathbb{Z}\), 如果系数不足可以在高次项补\(0\). 设\(n\)个单位根\(w_n^0,w_n^1,\cdots,w_n^{n-1}\)代入\(A(x)\)转化成点值表达, \[A(w_n^k)=\sum_{i=0}^{n-1}a_iw^{ki}, k = 0,1,\cdots,n-1\] 点值向量\(\vec y=\left(A(w_n^0),A(w_n^1),\cdots,A(w_n^{n-1}))\right)\)称作系数向量\(\vec a=(a_0,a_1,\cdots,a_n)\)的离散傅里叶变换(Discrete Fourier Transform, DFT), 记作\(\vec y = DFT_n(\vec a)\)]]></content>
  </entry>
  <entry>
    <title><![CDATA[Catalan数的原理与应用]]></title>
    <url>%2F2019%2F10%2F12%2FCatalan%E6%95%B0%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[由于\(C_2=C_3=1\) 设\(G(x)=C_2+C_3x+C_4x^2+\cdots\) \[x^2:C_4=C_2C_3+C_3C_2\\ x^3:C_5=C_2C_4+C_3C_3+C_4C_2\\ x^4:C_6=C_2C_5+C_3C_4+C_4C_3+C_5C_2\\ \vdots\] \[\begin{array}{l} G(x)-x-1&amp;=&amp;C_2(C_3x^2+C_4x^3+\cdots)\\ &amp;&amp;+C_3x(C_2x+C_3x^2+\cdots)\\ &amp;&amp;+C_4x^2(C_2x+C_3x^2+\cdots)+\cdots\\ &amp;=&amp;-x+C_2(C_2x+C_3x^2+\cdots)\\ &amp;&amp;+C_3x(C_2x+C_3x^2+\cdots)+\cdots \end{array}\] \[\Longrightarrow\quad\quad \begin{array}{l} G(x)-1&amp;=&amp;(C_2+C_3x+C_4x^2+\cdots)(C_2x+C_3x^2+\cdots)\\ &amp;=&amp;x[G(x)]2 \end{array}\] \[xG^2(x)-G(x)+1=0\\ G(x)=\frac{1-\sqrt{1-4x}}{2x}\] 而\(\displaystyle(1-4x)^{\frac{1}{2}}=1+\frac{1}{2}(-4x)-\frac{\displaystyle\frac{1}{2}(\frac{1}{2}-1)}{2!}(-4x)^2+\frac{\displaystyle\frac{1}{2}(\frac{1}{2}-1)(\frac{1}{2}-2)}{3!}(-4x)^3+\cdots\) 所以\((1-4x)^{\frac{1}{2}}\)中\(x^{n+1}\)项的系数为 \[\begin{array}{l} &amp;&amp;\displaystyle\frac{1}{(n+1)!}\frac{1}{2}\left(\frac{1}{2}-1\right)\left(\frac{1}{2}-2\right)\cdots\left(\frac{1}{2}-n\right)(-4)^{n+1}\\ &amp;=&amp;\displaystyle\frac{(-1)^{2n+1}}{(n+1)!}\frac{1\cdot3\cdot\cdots\cdot(2n-1)}{2^{n+1}}2^{2n+2}\\ &amp;=&amp;\displaystyle\frac{-2}{n+1}\frac{(2n)!}{(n!)^2}=\frac{-2}{n+1}\begin{pmatrix}2n\\n\end{pmatrix} \end{array}\] 故\(\displaystyle G(x)=\frac{1-\sqrt{1-4x}}{2x}\)且 \[C_{n+1}=\frac{1}{n}\begin{pmatrix}2n-2\\n-1\end{pmatrix}\] 由递推关系 \[nC_{n+1}=(4n-6)C_n\] \[G(x)=C_2x+C_3x^2+C_4x^3+\cdots\\ x:2C_3=4\cdot2C_2-6C_2\\ x^2:3C_4=4\cdot3C_3-6C_3\\ \vdots\] \[G&#39;(x)-1=4[xG(x)]&#39;-6G(x)\] \[G(x)=C\sqrt{1-4x}+\frac{1}{2}\] 由\(G(0)=0,\)有\(\displaystyle C=-\frac{1}{2},\)即\(\displaystyle G(x)=\frac{1-\sqrt{1-4x}}{2}\) \(C_{n+1}=C_2C_n+C_3C_{n-1}+\cdots+C_{n-1}C_3+C_nC_2\) \((n-3)C_n=\frac{n}{2}(C_3C_{n-1}+C_4C_{n-2}+\cdots+C_{n-1}C_3)\) 待填坑]]></content>
      <tags>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些字符串算法小结]]></title>
    <url>%2F2019%2F09%2F08%2F%E4%B8%80%E4%BA%9B%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%97%E6%B3%95%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[\(Manacher\)算法 众所周知, \(Manacher\)算法是一个求字符串中最长回文子序列问题的算法, 可以想到一个比较显然的做法: 长度为奇数的回文串以最中间字符的位置为对称轴, 而长度为偶数的回文串的对称轴在中间两个字符之间的空隙处. 于是我们考虑遍历这些对称轴, 并且同时向左右扩展, 直到左右两边的字符不同或到达边界. 这个算法的复杂度是\(O(n^2)\), 是无法过一些较大数据范围的题, 我们来思考一下这个算法的缺点, 显然, 回文串长度的奇偶性造成了对称轴的位置可能在某字符上, 也可能在两个字符之间的空隙处，要对两种情况分别处理. 为了解决这个问题, 可以强行在原字符串中插入其他本字符串不会出现的字符, 如"#". 对于整个算法的主体, 定义\(p[i]\)表示以字符\(i\)为回文中心的最长回文串的半径, 那么\(p[i]-1\)就是字符串中最长回文串的长度(除去'#'), 定义\(maxr\)为目前找到回文串的最右端, 中心为\(id\), 当我们扫描到的位置\(i\), 若\(id\leq i\leq maxr\), 可以找到对称点\(2*id-i\)求出其最长半径, 那么\(p[i] = \min(p[2*id-i], maxr-i)\) [模板]\(Manacher\)算法 123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 3e7 + 5;int n, ans, p[N];char s[N], str[N];void init() &#123; str[0] = str[1] = '#'; for (int i = 0; i &lt; n; ++i) &#123; str[(i&lt;&lt;1)+2] = s[i]; str[(i&lt;&lt;1)+3] = '#'; &#125; n = (n&lt;&lt;1) + 2; str[n] = 0;&#125;void manacher() &#123; int maxr = 0, id = 0; for (int i = n; str[i] != 0; ++i) str[i] = 0; for (int i = 1; i &lt; n; ++i) &#123; if (maxr &gt; i) p[i] = min(p[2*id-i], maxr - i); else p[i] = 1; for (; str[i+p[i]] == str[i-p[i]]; ++p[i]); if (p[i] + i &gt; maxr) &#123; maxr = p[i] + i; id = i; &#125; &#125;&#125;int main()&#123; scanf("%s", s); n = strlen(s); init(); manacher(); for (int i = 0; i &lt; n; ++i) ans = max(ans, p[i]); printf("%d\n", ans - 1); return 0;&#125; \(KMP\)算法 \(KMP\)算法, 又名模式匹配算法, 能在线性时间内判定字符串\(B[1\sim m]\)是否为字符串\(A[1\sim n]\)的字串, 并求出字符串\(B\)在字符串\(A\)中各次出现的位置. 容易想到一个\(O(nm)\)的朴素算法, 暴力枚举字符串\(B\)中每个位置\(i\), 逐一比较\(B[1]\)与\(A[i]\), \(B[2]\)与\(A[i+1]\cdots\)是否相等. 而\(KMP\)算法在匹配前会预处理模式串\(B\), 具体步骤如下: 对字符串\(B\)进行自我匹配, 求出数组\(next\), 其中\(next[i]\)表示"\(B\)中以i结尾的非前缀子串"与"\(B\)的前缀"能够匹配的最大长度. 即:\(next[i]=\max\{j\},\) 其中\(j&lt;i\)并且\(B[i-j+1\sim i]=B[1\sim j]\), 若不存在这样的\(j\)， 则\(next[i]=0\) 对字符串\(B\)与\(A\)进行匹配, 求出一个数组\(f\), 其中\(f[i]\)表示"\(A\)中以\(i\)结尾的字串"与"\(B\)的前缀"能够匹配的最长长度. 即:\(f[i]=\max\{j\}\), 其中\(j\leq i\)并且\(A[i-j+1\sim i]=B[1\sim j]\) 如果我们采用朴素算法计算\(next\)数组, 即枚举\(j\in[1,i-1]\), 并检查\(A[i-j+1\sim i]\)与\(A[1\sim j]\)是否相等. 时间复杂度不会低于\(O(n^2)\), 为了更快求解\(next\), 有以下引理. 引理 若\(j_0\)是\(next[i]\)的一个"候选项", 即\(j_0&lt;i\)且\(A[i-j_0+1\sim i]=A[1\sim j_0]\), 则小于\(j_0\)的最大的\(next[i]\)的"候选项"是\(next[j_0]\). 也即\(next[j_0]+1\sim j_0-1\)之间的数都不是\(next[i]\)的候选项 [模板]\(KMP\)算法 123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e6 + 5;char a[N], b[N];int n, m, Next[N];void calc() &#123; for (int i = 2, j = 0; i &lt;= m; ++i) &#123; while (j &amp;&amp; b[i] != b[j+1]) j = Next[j]; if (b[i] == b[j+1]) j++; Next[i] = j; &#125;&#125;int main()&#123; scanf("%s", a + 1); scanf("%s", b + 1); n = strlen(a + 1), m = strlen(b + 1); calc(); for (int i = 1, j = 0; i &lt;= n; ++i) &#123; while (j &gt; 0 &amp;&amp; a[i] != b[j+1]) j = Next[j]; if (a[i] == b[j+1]) j++; if (j == m) &#123;printf("%d\n", i - m + 1); j = Next[j];&#125; &#125; for (int i = 1; i &lt;= m; ++i) printf("%d ", Next[i]); return 0;&#125; \(Trie\)(字典树) \(Trie\)是一种用于实现字符串快速检索的多叉树结构, 其基本操作如下: 若\(P\)的\(c\)字符指针指向一个已经存在的节点\(Q\), 则令\(P=Q\) 若\(P\)的\(c\)字符指针指向空, 则新建一个节点\(Q\), 令\(P\)的\(c\)字符指针指向\(Q\), 然后令\(P=Q\) 123456789101112131415161718192021int trie[N][26], tot = 1;void Insert(char *str) &#123; int len = strlen(str), p = 1; for (int k = 0; k &lt; len; ++k) &#123; int ch = str[k] - 'a'; if (!trie[p][ch]) trie[p][ch] = ++tot; p = trie[p][ch]; &#125; ed[p]++;&#125;int Search(char *str) &#123; int len = strlen(str), p = 1; int ans = 0; for (int k = 0; k &lt; len; ++k) &#123; p = trie[p][str[k]-'a']; if (!p) return ans; ans += ed[p]; &#125; return ans;&#125; \(AC\)自动机 很多聚聚都说\(AC\)自动机就是在\(trie\)树上进行\(KMP\)]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[组合数性质探究]]></title>
    <url>%2F2019%2F09%2F06%2F%E7%BB%84%E5%90%88%E6%95%B0%E6%80%A7%E8%B4%A8%E6%8E%A2%E7%A9%B6%2F</url>
    <content type="text"><![CDATA[首先我们回顾一下一些简单性质 \(\begin{pmatrix}n\\k\end{pmatrix}=\displaystyle\frac{n!}{k!(n-k)!}\) \(\begin{pmatrix}n\\k\end{pmatrix}=\displaystyle\frac{n}{k}\begin{pmatrix}n-1\\k-1\end{pmatrix}\) \(\begin{pmatrix}n\\k\end{pmatrix}=\begin{pmatrix}n-1\\k\end{pmatrix}+\begin{pmatrix}n-1\\k-1\end{pmatrix}\) \(\begin{pmatrix}n\\m\end{pmatrix}\begin{pmatrix}m\\k\end{pmatrix}=\begin{pmatrix}n\\k\end{pmatrix}\begin{pmatrix}n-k\\m-k\end{pmatrix}\) \(\displaystyle\sum_{m=0}^n\begin{pmatrix}m\\k\end{pmatrix}=\begin{pmatrix}n+1\\k+1\end{pmatrix}\) \(\displaystyle\sum_{k=0}^nk\begin{pmatrix}n\\k\end{pmatrix}=n2^{n-1},\quad\sum_{k=0}^nk^2\begin{pmatrix}n\\k\end{pmatrix}=n(n+1)2^{n-2}\) 组合数的计算 利用\(性质3\) 12345memset(C, 0, sizeof(C));for (int i = 0; i &lt;= n; ++i) &#123; C[i][0] = 0; for (int j = i; j &lt;= i; ++j) C[i][j] = C[i-1][j-1] + C[i-1][j];&#125; 预处理阶乘和阶乘逆元 \(Lucas\)定理 \[\begin{pmatrix}n\\m\end{pmatrix}\equiv\begin{pmatrix}\lfloor n/p\rfloor\\\lfloor m/p\rfloor\end{pmatrix}\begin{pmatrix}n\mod p\\m\mod p\end{pmatrix}\pmod p\qquad (p为素数)\] \(proof:\quad\)设\(n=sp+q,m=tp+r\ (q,r\leq p)\),那么 \[\begin{array}{l} (1+x)^n&amp;=&amp;\left((1+x)^p\right)^s(1+x)^q\\ &amp;\equiv&amp;(1+x^p)^s(1+x)^q\pmod p\\ &amp;=&amp;\displaystyle\sum_{i=0}^s\begin{pmatrix}s\\i\end{pmatrix}x^{ip}\sum_{j=0}^q\begin{pmatrix}q\\j\end{pmatrix}x^j\\ \end{array}\] 可以得到 \[(1+x)^{sp+q}\equiv\sum_{i=0}^s\begin{pmatrix}s\\i\end{pmatrix}x^{ip}\sum_{j=0}^q\begin{pmatrix}q\\j\end{pmatrix}x^j\pmod p\] \(LHS\)中\((1+x)^{sp+q}\)中的\(x^{tp+r}\)系数为\(\begin{pmatrix}sp+q\\tp+r\end{pmatrix}\), \(RHS\)中的\(x^{tp+r}\)系数为\(\begin{pmatrix}s\\t\end{pmatrix}\begin{pmatrix}q\\r\end{pmatrix}\), 从而 \[\begin{pmatrix}sp+q\\tp+r\end{pmatrix}\equiv\begin{pmatrix}s\\t\end{pmatrix}\begin{pmatrix}q\\r\end{pmatrix}\pmod p\] 这与原命题等价, 证毕. \(Lucas\)定理模板题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define pii pair&lt;int,int&gt;#define inc(i,l,r) for(int i=l;i&lt;=r;++i)#define dec(i,l,r) for(int i=r;i&gt;=l;--i)#define mem(a,v) memset(a, v, sizeof(a))const int N = 1e5 + 5, INF = 0x3f3f3f3f;template &lt;typename T&gt;void read(T &amp;x)&#123; x = 0; ll f = 1; char ch = getchar(); while (!isdigit(ch)) &#123;if(ch == '-') f = -1; ch = getchar();&#125; while (isdigit(ch)) x = (x&lt;&lt;3) + (x&lt;&lt;1) + ch - '0', ch = getchar(); x *= f;&#125;ll t, p, f[N];ll power(ll a, ll b) &#123; ll res = 1 % p; for (; b; b &gt;&gt;= 1, a = a * a % p) if (b &amp; 1) res = res * a % p; return res;&#125;ll C(ll n, ll m) &#123; if (m &gt; n) return 0; return f[n] * power(f[m], p - 2) % p * power(f[n-m], p - 2) % p;&#125;ll lucas(ll n, ll m) &#123; if (!m) return 1; return C(n % p, m % p) * lucas(n / p, m / p) % p;&#125;int main()&#123; read(t); ll n, m; while (t--) &#123; read(n), read(m), read(p); f[0] = 1; inc(i,1,p) f[i] = f[i-1] * i % p; printf("%lld\n", lucas(n + m, m)); &#125; return 0;&#125; 勒让德定理\((\)或者叫扩展\(Lucas\)\()\) 勒让德定理：在正数\(n!\)的素因子标准分解式中，素数\(p\)的最高指数为\((n!)=\displaystyle\sum_{m=1}^\infty\left[\frac{n}{p^m}\right]\)]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈几个特殊函数]]></title>
    <url>%2F2019%2F08%2F28%2F%E6%B5%85%E8%B0%88%E5%87%A0%E4%B8%AA%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[\(\Gamma函数\) \(\Gamma\)函数是由如下含参数变量定义的积分, 又称第二类\(Euler\)积分, 其含参积分定义为 \[\Gamma(s)=\int_0^{+\infty}x^{s-1}e^{-x}\mathrm{d}x \tag{1}\] 它有 \(Gauss\)无穷乘积分解(\(Euler-Gauss\)公式) \[\Gamma(x)=\lim_{n\to\infty}\frac{n!n^x}{x(x+1)\cdots(x+n)}\] 性质: \(\Gamma(s+1)=s\Gamma(s)\ (s&gt;0)\) \(\Gamma(s)=2\displaystyle\int_0^{+\infty}x^{2s-1}e^{-x^2}\mathrm{d}x\) \(\Gamma(s)\)在\((0,+\infty)\)上为严格下凸函数, 它及其任意阶导数都连续, 且 \[\Gamma^{(n)}(s)=\int_0^{+\infty}x^{s-1}(\ln x)^ne^{-x}\mathrm{d}x\] \(\rm{B}函数\) \({\rm{B}}\)函数是由如下含两个参变量的瑕积分定义的函数 \[{\rm{B}}\left(p,q\right)=\int_0^1x^{p-1}(1-x)^{q-1}\mathrm{d}x,\quad p,q&gt;0 \tag{2}\] 性质: \({\rm{B}}(p,q)={\rm{B}}(q,p)\) \({\rm{B}}(p,q)=\displaystyle\frac{p-1}{p+q-1}{\rm{B}}(p-1,q)\) \({\rm{B}}(p,q)=2\displaystyle\int_0^\frac{\pi}{2}\cos^{2p-1}\theta\sin^{2q-1}\theta\mathrm{d}\theta\) \({\rm{B}}(p,q)=\displaystyle\int_0^{+\infty}\frac{x^{q-1}}{(1+x)^{p+q}}\mathrm{d}x\) 二者的关系 设\(p&gt;0,q&gt;0\)则有\({\rm{B}}(p,q)=\displaystyle\frac{\Gamma(p)\Gamma(q)}{\Gamma(p+q)}\) 证明: 由性质知 \[\Gamma(p)=2\int_0^{+\infty}x^{2p-1}e^{-x^2}\mathrm{d}x,\quad\Gamma(q)=2\int_0^{+\infty}x^{2q-1}e^{-x^2}\mathrm{d}x\] 令\(D=\left\{(x,y):0\leq x&lt;+\infty,0\leq y&lt;+\infty\right\}\), 则有 \[\Gamma(p)\Gamma(q)=4\iint_Dx^{2p-1}y^{2q-1}e^{-(x^2+y^2)}\mathrm{d}x\mathrm{d}y\] 利用极坐标变换, 记\(D_1=\displaystyle\left\{(r,\theta):0&lt;r&lt;+\infty,0\leq\theta\leq\frac{\pi}{2}\right\}\), 则有 \[\begin{array}{l} \Gamma(p)\Gamma(q)&amp;=&amp;4\displaystyle\iint_{D1}r^{2(p+q)-1}e^{-r^2}\cos^{2p-1}\theta\sin^{2q-1}\theta\mathrm{d}r\mathrm{d}\theta\\ &amp;=&amp;\displaystyle\left(2\int_0^\frac{\pi}{2}\cos^{2p-1}\theta\sin^{2q-1}\theta\mathrm{d}\theta\right)\left(2\int_0^{+\infty}r^{2(p+q)-1}e^{-r^2}\mathrm{d}r\right)\\ &amp;=&amp;\displaystyle{\rm{B}}(p,q)\Gamma(p+q) \end{array}\] 证毕. (余元公式) 设\(0&lt;p&lt;1\), 则有 \[{\rm{B}}(p,1-p)=\Gamma(p)\Gamma(1-p)=\frac{\pi}{\sin p\pi}.\] 证明: 由于\({\rm{B}}(p,1-p)=\displaystyle\int_0^{+\infty}\frac{x^{p-1}}{1+x}\mathrm{d}x\), 利用变量替换\(x=\frac{1}{t}\)有: \[\int_1^{+\infty}\frac{x^{p-1}}{1+x}\mathrm{d}x=\int_0^1\frac{x^{-p}}{1+x}\mathrm{d}x,\] 将\(\displaystyle\frac{1}{1+x}\)展开成幂级数, 从而有 \[\begin{array}{l} {\rm{B}}(p,1-p)&amp;=&amp;\displaystyle\lim_{r\to1^-}\int_0^r\frac{x^{p-1}+x^{-p}}{1+x}\mathrm{d}x\\ &amp;=&amp;\displaystyle\lim_{r\to1^-}\int_0^r\left[\sum_{k=0}^{+\infty}(-1)^kx^{k+p-1}+\sum_{k=0}^{+\infty}(-1)^kx^{k-p}\right]\mathrm{d}x\\ &amp;=&amp;\displaystyle\lim_{r\to1^-}\left[\sum_{k=0}^{+\infty}\frac{(-1)^k}{k+p}r^{k+p}+\sum_{k=0}^{+\infty}\frac{(-1)^k}{k-p+1}r^{k-p+1}\right]\\ &amp;=&amp;\displaystyle\sum_{k=0}^{+\infty}\frac{(-1)^k}{k+p}+\sum_{k=0}^{+\infty}\frac{(-1)^k}{k-p+1}\\ &amp;=&amp;\displaystyle\frac{1}{p}+\sum_{k=1}^{+\infty}(-1)^k\left(\frac{1}{k+p}+\frac{1}{p-k}\right)\\ &amp;=&amp;\displaystyle\frac{1}{p}+\sum_{k=1}^{+\infty}(-1)^k\frac{2p}{p^2-k^2}. \end{array}\] 而\(\cos px\)的\(Fourier\)级数为 \[\cos px=\frac{\sin px}{\pi}\left[\frac{1}{p}+\sum_{k=1}^{+\infty}(-1)^k\frac{2p}{p^2-k^2}\cos kx\right]\] 在\(\left|x\right|\leq\pi\)处处收敛, 令\(x=0\)即得 \[{\rm{B}}(p,1-p)=\frac{1}{p}+\sum_{k=1}^{+\infty}(-1)^k\frac{2p}{p^2-k^2}=\frac{\pi}{\sin p\pi}.\] 证毕. 注:令\(p=\displaystyle\frac{1}{2}\), 得 \[\Gamma^2\left(\frac{1}{2}\right)=\frac{\displaystyle\Gamma\left(\frac{1}{2}\right)\Gamma\left(\frac{1}{2}\right)}{\Gamma(1)}={\rm{B}}(\frac{1}{2},\frac{1}{2})=\pi\] 则\(\displaystyle\int_0^{+\infty}e^{-x^2}\mathrm{d}x=\frac{1}{2}\Gamma\left(\frac{1}{2}\right)=\frac{\sqrt\pi}{2}\), 也是一个得到这个重要等式的方法. 求\(\Bbb{R}^n\)中单位球体\(D:x_1^2+x_2^2+\cdots x_n^2\leq1\)的体积. 分析: 考虑用与球面类似的换元求解 解: 由\(n\)重积分的集合意义, 所求体积为 \[V=\iint\cdots\int_D\mathrm{d}x_1\mathrm{d}x_2\cdots\mathrm{d}x_n.\] 作变换 \[\begin{cases} x_1&amp;=&amp;r\cos\theta_1,\\ x_2&amp;=&amp;r\sin\theta_1\cos\theta_2\\ x_3&amp;=&amp;r\sin\theta_1\sin\theta_2\cos\theta_3\\ \cdots\cdots\\ x_{n-1}&amp;=&amp;r\sin\theta_1\sin\theta_2\cdots\sin\theta_{n-2}\cos\theta_{n-1}\\ x_{n}&amp;=&amp;r\sin\theta_1\sin\theta_2\cdots\sin\theta_{n-2}\sin\theta_{n-1} \end{cases}\] 其中\(\quad 0&lt;r&lt;1, 0&lt;\theta_1,\cdots,\theta_{n-2}&lt;\pi,0&lt;\theta_{n-1}&lt;2\pi\), 则其\(Jacobian\)行列式 \[\displaystyle\frac{\partial(x_1,x_2,\cdots,x_n)}{\partial(r,\theta_1,\theta_2,\cdots,\theta_{n-1})}=r^{n-1}\sin^{n-2}\theta_1\sin^{n-3}\theta_2\cdots\sin\theta_{n-2}\] 由此 \[\begin{array}{l} V &amp;=&amp; \displaystyle\iint\cdots\int_D\mathrm{d}x_1\mathrm{d}x_2\cdots\mathrm{d}x_n\\ &amp;=&amp; \displaystyle\int_0^{2\pi}\mathrm{d}\theta_{n-1}\int_0^\pi\mathrm{d}\theta_{n-2}\cdots\int_0^\pi\mathrm{d}\theta_1\int_0^1r^{n-1}\sin^{n-2}\theta_1\sin^{n-3}\theta_2\cdots\sin\theta_{n-2}\mathrm{d}r\\ &amp;=&amp; \displaystyle\frac{2\pi}{n}\left(\int_0^\pi\sin^{n-2}\theta_1\mathrm{d}\theta_1\right)\left(\int_0^\pi\sin^{n-3}\theta_2\mathrm{d}\theta_2\right)\cdots\left(\int_0^\pi\sin\theta_{n-2}\mathrm{d}\theta_{n-2}\right)\\ &amp;=&amp; \displaystyle\frac{2\pi}{n}{\rm{B}}\left(\frac{1}{2}, \frac{n-1}{2}\right){\rm{B}}\left(\frac{1}{2},\frac{n-2}{2}\right)\cdots{\rm{B}}\left(\frac{1}{2},1\right)\\ &amp;=&amp; \displaystyle\frac{2\pi}{n}\cdot\frac{\displaystyle\Gamma\left(\frac{1}{2}\right)\Gamma\left(\frac{n-1}{2}\right)}{\displaystyle\Gamma\left(\frac{n}{2}\right)}\cdot\frac{\displaystyle\Gamma\left(\frac{1}{2}\right)\Gamma\left(\frac{n-2}{2}\right)}{\displaystyle\Gamma\left(\frac{n-1}{2}\right)}\cdots\frac{\displaystyle\Gamma\left(\frac{1}{2}\right)\Gamma(1)}{\displaystyle\Gamma\left(\frac{3}{2}\right)}\\ &amp;=&amp; \displaystyle\frac{2\pi}{n}\cdot\frac{\displaystyle\Gamma^{n-2}\left(\frac{1}{2}\right)}{\displaystyle\Gamma\left(\frac{n}{2}\right)}\\ &amp;=&amp; \displaystyle\frac{\displaystyle\pi^{\frac{n}{2}}}{\displaystyle\Gamma\left(\frac{n}{2}+1\right)}. \end{array}\] \(\zeta函数\) \(Riemann\ zeta\) 函数\(\zeta(s)\), 是一个关于复数\(s\)的函数, 在在复平面上, \(s\)的实数部分\(\sigma=\scr{R}s&gt;1\)时, \(\zeta(s)=\displaystyle\sum_{n=1}^\infty\frac{1}{n^s}\) 特殊点取值 考虑调和级数\(\zeta(1)=\displaystyle\sum_{i=1}^\infty\frac{1}{n}\), 由\(Cauchy\)判别法, 级数\(S_n\)收敛当且仅当\(\forall \epsilon&gt;0, \exists N, st.\ m,n&gt;N, \left|S_m-S_n\right|&lt;\epsilon\) \[\left|S_{2n}-S_n\right|=\frac{1}{n+1}+\cdots+\frac{1}{2n}&gt;\frac{1}{2n}+\cdots+\frac{1}{2n}=\frac{1}{2}\] 故调和级数发散 \(Parseval\)等式 \[\frac{1}{\pi}\int_{-\pi}^\pi\left|f(x)\right|^2=\frac{a_0^2}{2}+\sum_{n=1}^\infty(a_n^2+b_n^2)\] \(\displaystyle\sum_{n=1}^\infty\frac{1}{n^2}=\frac{\pi^2}{6}\) \(\displaystyle\sum_{n=1}^\infty\frac{1}{n^4}=\frac{\pi^4}{90}\) \(zeta\)函数的积分形式 \[\zeta(s)=\sum_{n=1}^\infty\frac{1}{n^{s}}=\frac{1}{\Gamma(s)}\int_0^{+\infty}\frac{x^{s-1}}{e^x-1}\mathrm{d}x,\quad s&gt;1\] 求\(\displaystyle\int_0^1\frac{\ln x}{1-x}\mathrm{d}x\) 解: 令\(x=e^{-t},\) 则 \[\int_0^1\frac{\ln x}{1-x}\mathrm{d}x=\int_{+\infty}^0\frac{-t}{1-e^{-t}}e^{-t}(-\mathrm{d}t)=-\int_0^{+\infty}\frac{t}{e^t-1}\mathrm{d}t\] 在结论中取\(s=2\), 则 \[\int_0^1\frac{\ln x}{1-x}\mathrm{d}x=-\Gamma(2)\sum_{n=1}^{\infty}\frac{1}{n^2}=-\frac{\pi^2}{6}\]]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[反演原理及应用]]></title>
    <url>%2F2019%2F08%2F25%2F%E5%8F%8D%E6%BC%94%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[什么是反演 对于数列\(\left\{f_n\right\}\)以及数列\(\left\{g_n\right\}\)满足 \[g_n=\sum_{i=0}^na_{ni}f_i \tag{1}\] 反演便是利用\(\left\{g_n\right\}\)反推出\(\left\{f_n\right\}\), 也即 \[f_n=\sum_{i=0}^nb_{ni}g_i \tag{2}\] 本质上来说这是一个反解线性方程组的过程, 但观察后会发现整个方程组是一个下三角矩阵, 可以思考出更加快捷的方法 反演原理 为了便于后面的叙述, 首先引入\(\delta(i,j)\)函数\((Kronecker&#39;s\ delta)\), 它的定义为 \[\delta\left(i,j\right)=\begin{cases}1\quad i=j\\0\quad i\neq j\end{cases}\qquad(\text{也可记为}[i=j])\] 下面考虑反演的过程, 考虑下面的式子应该满足什么条件 \[ \sum_{i=0}^nb_{ni}g_i=f_n \tag{3} \] \[ \begin{array}{l} LHS&amp;=&amp;\displaystyle\sum_{i=0}^nb_{ni}g_i\\ &amp;=&amp;\displaystyle\sum_{i=0}^nb_{ni}\sum_{j=0}^ia_{ij}f_j\\ &amp;=&amp;\displaystyle\sum_{i=0}^nf_i\sum_{j=i}^nb_{nj}a_{ji} \end{array} \] 为了便于理解最后一步, 我们用矩阵进行表示 \[ \begin{bmatrix} b_{n0}a_{00}f_0\\ b_{n1}a_{10}f_0 &amp; b_{n1}a_{11}f_1\\ b_{n2}a_{20}f_0 &amp; b_{n2}a_{21}f_1 &amp; b_{n2}a_{22}f_2\\ \vdots &amp; \vdots &amp; \ddots \\ b_{nn}a_{n0}f_0 &amp; b_{nn}a_{n1}f_1 &amp; \cdots &amp; b_{nn}a_{nn}f_n \end{bmatrix} \] 前一个是对行进行, 再将行加起来, 后一个是对列进行, 再将列加起来 因此, 式\((3)\)成立的条件等价于 \[\sum_{j=i}^nb_{nj}a_{ji}=\delta(n,i) \tag{4}\] 同理, 将\(f\)代入带\(g\)的求和式中, 可以推出 \[\sum_{j=i}^na_{nj}b_{ji}=\delta(n,i) \tag{5}\] 如果某个数列满足上面的条件, 我们便阔以利用反演公式 二项式反演 原理 二项式反演\((binomial\ inversion)\)在容斥中经常用到, 可以表示为 \[ f_n=\sum_{i=0}^n\left(-1\right)^n\begin{pmatrix}n\\i\end{pmatrix}g_i\Leftrightarrow g_n=\sum_{i=0}^n\left(-1\right)^n\begin{pmatrix}n\\i\end{pmatrix} f_i \tag{6} \] 可以写成另一种常见形式 \[ f_n=\sum_{i=0}^n\begin{pmatrix}n\\i\end{pmatrix}g_i\Leftrightarrow g_n=\sum_{i=0}^n\left(-1\right)^{n-i}\begin{pmatrix}n\\i\end{pmatrix}f_i \tag{7} \] 证明: \[\begin{array}{l} g_n&amp;=&amp;\displaystyle\sum_{i=0}^n\left(-1\right)^{n-i}\begin{pmatrix}n\\i\end{pmatrix}f_i\\ &amp;=&amp;\displaystyle\sum_{i=0}^n\left(-1\right)^{n-i}\begin{pmatrix}n\\i\end{pmatrix}\sum_{j=0}^i\begin{pmatrix}i\\j\end{pmatrix}g_j\\ &amp;=&amp;\displaystyle\sum_{i=0}^ng_i\sum_{j=i}^n\begin{pmatrix}n\\j\end{pmatrix}\begin{pmatrix}j\\i\end{pmatrix}\left(-1\right)^{n-j}\\ &amp;=&amp;\displaystyle\sum_{i=0}^ng_i\sum_{j=i}^n\begin{pmatrix}n\\i\end{pmatrix}\begin{pmatrix}n-i\\j-i\end{pmatrix}\left(-1\right)^{n-j}\\ &amp;=&amp;\displaystyle\sum_{i=0}^ng_i\begin{pmatrix}n\\i\end{pmatrix}\sum_{j=0}^{n-i}\begin{pmatrix}n-i\\j\end{pmatrix}\left(-1\right)^{n-i-j}\\ &amp;=&amp;\displaystyle\sum_{i=0}^ng_i\begin{pmatrix}n\\i\end{pmatrix}\left(1-1\right)^{n-i}\\ &amp;=&amp;g_n \end{array}\] 应用 错位排列 对于长度为\(n\)的序列\(\{a_i\}\), 求所有满足\(1\leq i\leq n\), 使得\(a_i\neq i\)的种类数 一个高中生想到的常规方法可能是利用递推, 记所求为\(D_n\), \(n\)个错位排列按照第一位是\(2,3,\cdots,n\)分成\(n-1\), 每个组排列个数一样多, 考虑其中一组, 不妨设第一位为\(2\), 若第\(2\)位是\(1\),有\(D_{n-2}\)种, 否则有\(D_{n-1}\)种, 结合\(D_1=0,\ D_2=1\), 从而有 \[D_n=(n-1)(D_{n-1}+D_{n-2}) \tag{8}\] \[D_n-nD_{n-1}=-\left(D_{n-1}-(n-1)D_{n-2}\right)=\cdots=(-1)^{n-2} \tag{9}\] \[D_n=nD_{n-1}+(-1)^n=\cdots=n!\sum_{i=0}^n\frac{(-1)^i}{i!} \tag{10}\] 回到正题, 我们有一个有意思的解法, 设\(f_i\)为恰好有\(i\)个位置是不变的排列, 那么 \[n!=\sum_{i=0}^n\begin{pmatrix}n\\i\end{pmatrix}f_i \tag{11}\] 可以看粗其形式和反演公式很像, 令\(g_i=i!\), 有二项式反演 \[\begin{array}{l} f_n&amp;=&amp;\displaystyle\sum_{i=0}^n(-1)^{n-i}\begin{pmatrix}n\\i\end{pmatrix}g_i\\ &amp;=&amp;\displaystyle\sum_{i=0}^n(-1)^{n-i}\frac{n!}{(n-i)!}\\ &amp;=&amp;n!\displaystyle\sum_{i=0}^n\frac{(-1)^i}{i!} \end{array} \] 染色问题 \(n\)个球排成一行, 有\(m\)种颜色, 每个球染一个颜色, 相邻两个球染不同颜色, 每种颜色至少使用一次, 求染色方案数 不考虑每种颜色至少用一次这一条件, 那么答案显然是\(m(m-1)^{n-1}\), 设\(f_i\)为恰好使用\(i(i=0,1,2,\cdots,k)\)种颜色的方案数, 那么 \[m(m-1)^{n-1}=\sum_{i=0}^m\begin{pmatrix}m\\i\end{pmatrix}f_i \tag{12}\] 经过反演得到 \[f_m=\sum_{i=0}^m(-1)^{m-i}\begin{pmatrix}m\\i\end{pmatrix}g_i \tag{13}\] \(BZOJ2839\):集合计数 记\(b_i\)为交集有至少\(i\)个集合的个数, 枚举\(i\)个交集后, 共有\(2^{n-i}\)个互不相同的集合, 每个集合又有选与不选两种方案, 故\(b_i=\begin{pmatrix}n\\i\end{pmatrix}2^{2^{n-i}}\), 那么我们开始演了 \[b_k=\sum_{i=k}^n\begin{pmatrix}i\\k\end{pmatrix}a_i\quad\Leftrightarrow\quad a_k=\sum_{i=k}^n(-1)^{n-k}\begin{pmatrix}i\\k\end{pmatrix}b_i\] [点击显示/隐藏代码] 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define pii pair&lt;int,int&gt;#define inc(i,l,r) for(int i=l;i&lt;=r;++i)#define dec(i,l,r) for(int i=r;i&gt;=l;--i)#define mem(a,v) memset(a,v,sizeof(a))const int N = 1e6, INF = 0x3f3f3f3f;const ll MOD = 1e9 + 7;template &lt;typename T&gt;void read(T &amp;x)&#123; x = 0; ll f = 1; char ch = getchar(); while (!isdigit(ch)) &#123;if(ch == '-') f = -1; ch = getchar();&#125; while (isdigit(ch)) x = (x&lt;&lt;3) + (x&lt;&lt;1) + ch - '0', ch = getchar(); x *= f;&#125;ll n, k, ans;ll fac[N], inv[N], p[N];ll power(ll a, ll b)&#123; ll res = 1; for (; b; a = a * a % MOD, b &gt;&gt;= 1) if (b &amp; 1) res = res * a % MOD; return res;&#125;ll C(ll n, ll m)&#123; return fac[n] * inv[m] % MOD * inv[n-m] % MOD;&#125;int main()&#123; read(n), read(k); fac[0] = inv[0] = p[0] = 1; inc(i,1,n) fac[i] = (ll)fac[i-1] * i % MOD, p[i] = (ll)p[i-1] * 2 % (MOD - 1); inv[n] = power(fac[n], MOD - 2); dec(i,1,n-1) inv[i] = (ll)inv[i+1] * (i + 1) % MOD; inc(i,k,n) &#123; (ans += MOD + ((i-k) &amp; 1 ? -1 : 1) * (C(i,k) * C(n,i) % MOD * (power(2, p[n-i]) % MOD))) %= MOD; &#125; printf("%lld\n", ans); return 0;&#125; 斯特林反演 原理 在这里, 先回顾一下斯特林数(\(dalao\)请自动忽略) 第一类斯特林数 定义: 将\(n\)个元素排成\(m\)个轮换的方法数 从\(n-1\)的情况推过来, 要么将最后一个元素放进自身的轮换, 要么将最后一个元素放进前\(n-1\)个元素分成的\(\begin{bmatrix}n-1\\m\end{bmatrix}\)个轮换中的一个, 可以得到: \[\begin{bmatrix}n\\m\end{bmatrix}=\begin{bmatrix}n-1\\m-1\end{bmatrix}+(n-1)*\begin{bmatrix}n-1\\m\end{bmatrix} \tag{14}\] 由于\(\begin{bmatrix}n\\ k\end{bmatrix}\)是\(n\)个元素恰好包含\(k\)个轮换的排列个数, 对所有的\(k\)求和, 必然得到排列的总数 \[\sum_{k=0}^n\begin{bmatrix}n\\ k\end{bmatrix}=n! \tag{15}\] 下面是与下降幂\(x^{\underline{n}}\)和阶乘幂\(x^{\overline{n}}\)的关系 \[x^{\underline{n}}=\sum_{i=0}^n\begin{bmatrix}n\\i\end{bmatrix}(-1)^{n-i}x^i \tag{16}\] 用归纳法证明 \[\begin{array}{l} x^{\underline{n+1}}&amp;=&amp;(x-n)x^{\underline{n}}\\ &amp;=&amp;(x-n)\displaystyle\sum_{i=0}^n\begin{bmatrix}n\\i\end{bmatrix}(-1)^{n-i}x^i\\ &amp;=&amp;\displaystyle\sum_{i=0}^n\begin{bmatrix}n\\i\end{bmatrix}(-1)^{n-i}x^{i+1}-n\sum_{i=0}^{n+1}\begin{bmatrix}n\\i\end{bmatrix}(-1)^{n-i}x^i\\ &amp;=&amp;\displaystyle\sum_{i=1}^{n+1}\begin{bmatrix}n\\i-1\end{bmatrix}(-1)^{n-i+1}x^{i}+n\sum_{i=0}^{n+1}\begin{bmatrix}n\\i\end{bmatrix}(-1)^{n-i+1}x^i\\ &amp;=&amp;\displaystyle\sum_{i=0}^{n+1}\left(\begin{bmatrix}n\\i-1\end{bmatrix}+n\begin{bmatrix}n\\i\end{bmatrix}\right)(-1)^{n-i+1}x^i\\ &amp;=&amp;\displaystyle\sum_{i=0}^{n+1}\begin{bmatrix}n+1\\i\end{bmatrix}(-1)^{n+1-i}x^i \end{array}\] 类似可以证明 \[x^{\overline{n}}=\sum_{i=0}^n\begin{bmatrix}n\\i\end{bmatrix}x^i \tag{17}\] 第二类斯特林数 定义: 将一个有\(n\)件物品的集合划分成\(m\)个非空子集的方法数 从\(n-1\)的情况推过来, 要么将最后一个元素单独放一类, 要么与前\(n-1\)个元素的某个非空子集放一起, 可以得到: \[\begin{Bmatrix}n\\m\end{Bmatrix}=\begin{Bmatrix}n-1\\m-1\end{Bmatrix}+m*\begin{Bmatrix}n-1\\m\end{Bmatrix} \tag{18}\] 下面是与下降幂\(x^{\underline{n}}\)和阶乘幂\(x^{\overline{n}}\)的关系 \[m^n=\sum_{i=0}^n\begin{Bmatrix}n\\i\end{Bmatrix}m^{\underline{i}} \tag{19}\] 用归纳法证明, 由于\(x*x^{\underline{i}}=x^{\underline{i+1}}+ix^{\underline{i}}\) \[\begin{array}{l} m^{n+1}&amp;=&amp;m\displaystyle\sum_{i=0}^n\begin{Bmatrix}n\\i\end{Bmatrix}m^{\underline{i}}\\ &amp;=&amp;\displaystyle\sum_{i=0}^n\begin{Bmatrix}n\\i\end{Bmatrix}m^{\underline{i+1}}+\sum_{i=0}^n\begin{Bmatrix}n\\i\end{Bmatrix}im^{\underline{i}}\\ &amp;=&amp;\displaystyle\sum_{i=1}^{n+1}\begin{Bmatrix}n\\i-1\end{Bmatrix}m^{\underline{i}}+\sum_{i=0}^{n+1}\begin{Bmatrix}n\\i\end{Bmatrix}im^{\underline{i}}\\ &amp;=&amp;\displaystyle\sum_{i=0}^{n+1}\left(\begin{Bmatrix}n\\i-1\end{Bmatrix}+i\begin{Bmatrix}n\\i\end{Bmatrix}\right)m^{\underline{i}}\\ &amp;=&amp;\displaystyle\sum_{i=0}^{n+1}\begin{Bmatrix}n+1\\i\end{Bmatrix}m^{\underline{i}} \end{array}\] 类似可以证明 \[m^n=\sum_{i=0}^n\begin{Bmatrix}n\\i\end{Bmatrix}(-1)^{n-i}m^{\overline{i}} \tag{20}\] 当然还有两个比较显然的东西 \[x^{\underline{n}}=(-1)(-x)^{\overline{n}} \tag{21}\] \[x^{\overline{n}}=(-1)(-x)^{\underline{n}} \tag{22}\] 反转公式 \[\sum_{k=m}^n(-1)^{n-k}\begin{bmatrix}n\\k\end{bmatrix}\begin{Bmatrix}k\\m\end{Bmatrix}=[m=n] \tag{23}\] \[\sum_{k=m}^n(-1)^{n-k}\begin{Bmatrix}n\\k\end{Bmatrix}\begin{bmatrix}k\\m\end{bmatrix}=[m=n] \tag{24}\] \(proof\ 1:\) \[\begin{array}{l} m^{\underline{n}}&amp;=&amp;\displaystyle\sum_{i=0}^n\begin{bmatrix}n\\i\end{bmatrix}(-1)^{n-i}m^i\\ &amp;=&amp;\displaystyle\sum_{i=0}^n\begin{bmatrix}n\\i\end{bmatrix}(-1)^{n-i}\sum_{j=0}^i\begin{Bmatrix}i\\j\end{Bmatrix}m^{\underline{j}}\\ &amp;=&amp;\displaystyle\sum_{i=0}^nm^{\underline{i}}\sum_{j=i}^n(-1)^{n-j}\begin{bmatrix}n\\j\end{bmatrix}\begin{Bmatrix}j\\i\end{Bmatrix} \end{array}\] \(proof\ 2:\) \[\begin{array}{l} m^n&amp;=&amp;\displaystyle\sum_{i=0}^n\begin{Bmatrix}n\\i\end{Bmatrix}m^{\underline{i}}\\ &amp;=&amp;\displaystyle\sum_{i=0}^n\begin{Bmatrix}n\\i\end{Bmatrix}\sum_{j=0}^i(-1)^{i-j}\begin{bmatrix}i\\j\end{bmatrix}m^j\\ &amp;=&amp;\displaystyle\sum_{i=0}^nm^i\sum_{j=i}^n(-1)^{n-j}\begin{Bmatrix}n\\j\end{Bmatrix}\begin{bmatrix}j\\i\end{bmatrix} \end{array}\] 斯特林反演 \[f(n)=\sum_{i=0}^n\begin{Bmatrix}n\\k\end{Bmatrix}g(k) \quad\Leftrightarrow\quad g(n)=\sum_{k=0}^n(-1)^{n-k}\begin{bmatrix}n\\k\end{bmatrix}f(k) \tag{25}\] \((25)\)的证明如下: \[\begin{array}{l} f(n)&amp;=&amp;\displaystyle\sum_{k=0}^n\begin{Bmatrix}n\\k\end{Bmatrix}g(k)\\ &amp;=&amp;\displaystyle\sum_{k=0}^n\begin{Bmatrix}n\\k\end{Bmatrix}\sum_{j=0}^k(-1)^{k-j}\begin{bmatrix}k\\j\end{bmatrix}f(j)\\ &amp;=&amp;\displaystyle\sum_{k=0}^n\sum_{j=k}^n\begin{Bmatrix}n\\j\end{Bmatrix}\begin{bmatrix}j\\k\end{bmatrix}(-1)^{j-k}f(k)\\ &amp;=&amp;\displaystyle\sum_{k=0}^n[k=n]f(k)\\ &amp;=&amp;f(n) \end{array}\] 莫比乌斯反演 原理 莫比乌斯函数\(\mu(m)\) 对所有整数\(m\geq1由等式\) \[\sum_{d|m}\mu(d)=\left[m=1\right] \tag{26}\] 来定义, 这个等式是一个递归式, 代入\(m=1,2,\cdots,12\)可以得到前\(12\)个值: \(m\) \(1\) \(2\) \(3\) \(4\) \(5\) \(6\) \(7\) \(8\) \(9\) \(10\) \(11\) \(12\) \(\mu(m)\) \(1\) \(-1\) \(-1\) \(0\) \(-1\) \(1\) \(-1\) \(0\) \(0\) \(1\) \(-1\) \(0\) \[g(m)=\sum_{d|m}f(d)\quad\Leftrightarrow\quad f(m)=\sum_{d|m}\mu(\frac{m}{d})g(d) \tag{27}\] \((27)\)的证明如下: \[\begin{array}{l} g(m)&amp;=&amp;\displaystyle\sum_{d|m}f(d)\\ &amp;=&amp;\displaystyle\sum_{d|m}\sum_{k|d}\mu(\frac{d}{k})g(k)\\ &amp;=&amp;\displaystyle\sum_{k|m}g(k)\sum_{d|m,k|d}\mu(\frac{d}{k})\\ &amp;=&amp;\displaystyle\sum_{k|m}g(k)\sum_{d|(m/k)}\mu(d)\\ &amp;=&amp;\displaystyle\sum_{k|m}[m/k=1]g(k)\\ &amp;=&amp;g(m) \end{array}\]]]></content>
      <tags>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM算法模板]]></title>
    <url>%2F2019%2F08%2F24%2FACM%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[基础 排序 归并排序 [点击显示/隐藏代码] 1234567891011121314void mergesort(int l, int r) &#123; if(l == r) return ; int mid = (l + r) &gt;&gt; 1; mergesort(l, mid); mergesort(mid + 1, r); int p = l, q = mid + 1, cnt = l; while(p &lt;= mid &amp;&amp; q &lt;= r)&#123; if(a[p] &lt; a[q]) t[cnt++] = a[p++]; else t[cnt++] = a[q++]; &#125; while(p &lt;= mid) t[cnt++] = a[p++]; while(q &lt;= r) t[cnt++] = a[q++]; for(int i = l; i &lt;= r; ++i) a[i] = t[i];&#125; 拓扑排序 [点击显示/隐藏代码] 1234567891011121314151617181920212223int head[N], u[N], v[N], deg[N], tot, cnt;inline void add(int x, int y) &#123; v[++tot] = y; u[tot] = head[x]; head[x] = tot; deg[y]++;&#125;void topsort() &#123; queue&lt;int&gt; q; for (int i = 1; i &lt;= n; ++i) if (!deg[i]) q.push(i); while (!q.empty()) &#123; int x = q.front(); q.pop(); a[++cnt] = x; for (int i = head[x]; i; i = u[i]) &#123; int y = v[i]; if (--deg[y] == 0) q.push(y); &#125; &#125;&#125; 数学 素数 \(Eratosthenes\)筛法 [点击显示/隐藏代码] 123456789//O(nloglogn)void sieve() &#123; memset(v, 0, sizeof(v)); for (int i = 2; i &lt;= N; ++i) &#123; if (v[i]) continue; p[++cnt] = i; for (int j = i; j &lt;= N / i; ++j) v[i*j] = 1; &#125;&#125; 线性筛法 [点击显示/隐藏代码] 1234567891011//O(n)void sieve() &#123; memset(v, 0, sizeof(v)); for (int i = 2; i &lt;= N; ++i) &#123; if (!v[i]) p[++cnt] = i; for (int j = 1; j &lt;= cnt &amp;&amp; p[j] * i &lt;= N; ++j) &#123; v[i*p[j]] = 1; if (i % p[j] == 0) break; &#125; &#125;&#125; 欧几里得 [点击显示/隐藏代码] 123456int gcd(int a, int b) &#123; return !b ? a : gcd(b, a % b);&#125;int lcm(int a, int b) &#123; return a / gcd(a, b) * b;&#125; 扩展欧几里得 在求出\(gcd(a,b)\)的同时求出二元一次不定方程\(ax+by=gcd(a,b)\)的一组整数解 [点击显示/隐藏代码] 1234567void exgcd(int a, int b, int &amp;x, int &amp;y) &#123; if (!b) x = 1, y = 0; else &#123; exgcd(b, a % b, x, y); y -= a / b * y; &#125;&#125; 欧拉函数 我们知道\(\varphi(n)\)表示小于\(n\)且与\(n\)互素的整数个数, 而\(n\)可分解为\(n=\displaystyle\prod_{i=1}^kp_i^{a_i}\), 根据容斥原理我们有 \[\varphi(n)=\sum_{S\subseteq\left\{p_1,p_2,\cdots,p_k\right\}}(-1)^{|S|}\frac{n}{\displaystyle\prod_{p_i\in S}p_i}\] 展开后可以得到 \[\varphi(n)=n*\prod_{i=1}^k\left(1-\frac{1}{p_i}\right)\] 若\(n\)是素数 , 有\(\varphi(n)=n−1\) 若\(gcd(n,m)=1\), 有\(\varphi(mn)=\varphi(m)\varphi(n)\) 若\(n\)和\(m\)是素数 , 有\(\varphi(nm)=nm−1\) 若\(p\)是素数 , 有\(\varphi(p^q)=p^q−p^{q−1}\) \(\displaystyle\sum_{d|m}\varphi(d)=m\) [点击显示/隐藏代码] 1234567891011121314151617181920//单个Euler函数值int phi(int n) &#123; int res = n; for (int i = 2; i * i &lt;= n; ++i) &#123; if (n % i == 0) &#123; res -= res / i; while (n % i == 0) n /= i; &#125; &#125; if (n &gt; 1) res -= res / n; return res; &#125;//O(nlogn)void euler(int n) &#123; for (int i = 1; i &lt;= n; ++i) phi[i] = i; for (int i = 2; i &lt;= n; ++i) if (phi[i] == i) for (int j = i; j &lt;= n; j += i) phi[j] = phi[j] / i * (i - 1);&#125; 数据结构 并查集 [点击显示/隐藏代码] 123int find(int x) &#123; return f[x] == x ? x : f[x] = find(f[x]);&#125; 图论 最短路 \(dijkstra\) [点击显示/隐藏代码] 1234567891011121314151617181920int n, m, s;int a[N][N], d[N], pre[N], vis[N];void dijkstra() &#123; for (int i = 1; i &lt;= n; ++i) &#123; d[i] = INF; vis[i] = 0; pre[i] = -1; &#125; d[s] = 0; for (int i = 1; i &lt; n; ++i) &#123; int x = -1; for (int j = 1; j &lt;= n; ++j) if (!vis[j] &amp;&amp; (x == -1 || d[j] &lt; d[x])) x = j; vis[x] = 1; for (int y = 1; y &lt;= n; ++y) if (d[y] &gt; d[x] + a[x][y]) &#123; d[y] = d[x] + a[x][y]; pre[y] = x; &#125; &#125;&#125; \(dijkstra(堆优化)\) [点击显示/隐藏代码] 12345678910111213141516171819202122232425262728293031struct Edge&#123; int next, to, w;&#125;e[M];inline void add(int x, int y, int z)&#123; e[++tot].w = z; e[tot].next = head[x]; e[tot].to = y; head[x] = tot;&#125;void dijkstra()&#123; d[s] = 0; q.push(make_pair(0, s)); while (!q.empty()) &#123; int x = q.top().second; q.pop(); if (vis[x]) continue; vis[x] = 1; for (int i = head[x]; i; i = e[i].next) &#123; int y = e[i].to; if (d[y] &gt; d[x] + e[i].w) &#123; d[y] = d[x] + e[i].w; q.push(make_pair(-d[y], y)); &#125; &#125; &#125;&#125; 最小生成树 \(Kruskal\)算法 比较适合于稀疏图 [点击显示/隐藏代码] 12345678910111213141516171819202122232425262728293031323334const int N = 5005;const int M = 2e5 + 5;int n, m, f[N];struct edge&#123; int u, v, w; friend bool operator &lt; (edge a, edge b) &#123; return a.w &lt; b.w; &#125;&#125;e[M];int Find(int x) &#123; if (f[x] == x) return x; return f[x] = Find(f[x]);&#125;int krusal() &#123; sort(e + 1, e + m + 1); int cnt = 0; int ans = 0; for (int i = 1; i &lt;= n; ++i) f[i] = i; for (int i = 1; i &lt;= m; ++i) &#123; int x = Find(e[i].u); int y = Find(e[i].v); if (x != y) &#123; ans += e[i].w; f[x] = y; cnt++; &#125; if (cnt == n - 1) break; &#125; if (cnt &lt; n - 1) return -1; //不连通 return ans;&#125; \(Prim\)算法 [点击显示/隐藏代码] 12345678910111213141516const int N = 5005;int n, m, ans;int a[N][N], d[N], v[N];void prim() &#123; memset(d, 0x3f, sizeof(d)); d[1] = 0; for (int i = 1; i &lt;= n; ++i) &#123; int x = 0; for (int j = 1; j &lt;= n; ++j) if (!v[j] &amp;&amp; (x == 0 || d[j] &lt; d[x])) x = j; v[x] = 1; for (int y = 1; y &lt;= n; ++y) if (!v[y]) d[y] = min(d[y], a[x][y]); &#125;&#125; 提高 图论 网络流初步 Edmonds-Karp [点击显示/隐藏代码] 1234567891011121314151617181920212223242526272829303132333435363738394041int n, m, s, t, maxflow, tot = 1;int ver[M], edge[M], Next[M], head[N], v[N], incf[N], pre[N];void add(int x, int y, int z) &#123; ver[++tot] = y, edge[tot] = z, Next[tot] = head[x], head[x] = tot; ver[++tot] = x, edge[tot] = 0, Next[tot] = head[y], head[y] = tot;&#125;bool bfs() &#123; memset(v, 0, sizeof(v)); queue&lt;int&gt; q; q.push(s); v[s] = 1; incf[s] = INF; while (!q.empty()) &#123; int x = q.front(); q.pop(); for (int i = head[x]; i; i = Next[i]) if (edge[i]) &#123; int y = ver[i]; if (v[y]) continue; incf[y] = min(incf[x], edge[i]); pre[y] = i; q.push(y); v[y] = 1; if (y == t) return 1; &#125; &#125; return 0;&#125;void EK() &#123; while (bfs()) &#123; int x = t; while (x != s) &#123; int i = pre[x]; edge[i] -= incf[t]; edge[i^1] += incf[t]; x = ver[i^1]; &#125; maxflow += incf[t]; &#125;&#125; Dinic [点击显示/隐藏代码] 12 附录 对拍 \(bat\)语言版本 [点击显示/隐藏代码] 1234567891011121314151617@echo offset cnt=0for /l %%i in (1,1,10) do ( mine.exe &lt; stdin%%i.txt &gt; out%%i.txt fc out%%i.txt stdout%%i.txt &gt; diff%%i.txt if errorlevel 1 ( set cnt=1 echo %%i:UnAccepted! ) if not errorlevel 1 ( del diff%%i.txt echo %%i:Accepted! ))if %cnt%==0 color a &amp;&amp; echo *** Totally Accepted! ***if %cnt%==1 color c &amp;&amp; echo *** Not All Accepted! ***pause vim配置 [点击显示/隐藏代码] 1234567syntax onset nuset tabstop=4set shiftwidth=4set cincolo eveningset mouse=a]]></content>
      <categories>
        <category>ACM</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[TikZ入门]]></title>
    <url>%2F2019%2F08%2F12%2FTikZ%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[在\(LaTex​\)中, 要用\(tikz​\)作图, 首先调用\(tikz​\)宏包和有关的程序库 12\usepackage&#123;tikz&#125;\usetikzlibrary&#123;&lt;list of libraries&gt;&#125; 然后开启\({tikzpicture}\)环境作图, 或者用\(\\ tikz\)开始作图. 各种命令必须以分号结束, 否则报错 命令\def 命令\def用于自定义一个对象, 对象名称以反斜线, 语法为 \def&lt;对象名称&gt;{定义内容} 下面是一个\wall的例子(需调用\(pattern\)库) 123456\begin&#123;tikzpicture&#125;\def\wall&#123; \fill [fill=black!50] (1,-.5) rectangle (2,.5); \pattern [pattern=bricks] (1,-.5) rectangle (2,.5); \draw [line width=1pt] (1cm+.5pt,-.5) -- ++(0,1);&#125;\wall\end&#123;tikzpicture&#125; 创建coordinate对象的句法及其命名 1234\path . . . coordinate[&lt;options&gt;](&lt;name&gt;)at(&lt;coordinate&gt;) . . . ;%将路径中的某个对象设置为 coordinate \coordinate [&lt;options&gt;](&lt;name&gt;)at(&lt;coordinate&gt;);%这是上一句法的简写，注意最好不要在该命令后面用 node 命令。]]></content>
      <categories>
        <category>LaTex</category>
      </categories>
      <tags>
        <tag>LaTex包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ1845 Sumdiv]]></title>
    <url>%2F2019%2F07%2F17%2FPOJ1845%20Sumdiv%2F</url>
    <content type="text"><![CDATA[\(Sumdiv\) 题意: 求\(A^B\)的所有约数之和\(\mod{9901}\left(1\leq A,B \leq5*10^7\right)\) 分析: A分解质因数为\(p_1^{c_1}\times p_2^{c_2}\times\cdots\times p_n^{c_n}\)。那么\(A^B\)表示为\(p_1^{Bc_1}\times p_2^{Bc_2}\times\cdots\times p_n^{Bc_n}\)。\(A^B\)的所有约数表示为集合\(\{p_1^{k_1}\times p_2^{k_2}\times\cdots\times p_n^{k_n}\}\)，其中\(0\leq k_i \leq B\times c_i\left(1\leq i \leq n\right)\) 由乘法分配律, \(A^B\)的所有约数之和为: \[\left(1+p_1+\cdots+p_1^{B*c_1}\right)*\left(1+p_2+\cdots+p_2^{B*c_2}\right)*\cdots\\*\left(1+p_n+\cdots+p_n^{B*c_n}\right)=\prod_{i=1}^n\left(\sum_{j=0}^{B*c_i}\left(p_i\right)^j\right)\] 括号内为等比数列，直接使用求和公式，需要做除法。答案还需对9901取模，mod运算只对加、减、乘有分配律，不能对分子分母取模后做除法，换一种思路，用分治法对等比数列求和。 用分治法求\(\displaystyle\sum_{i=1}^cp^i\quad\text{若c为奇数:}\) \[\sum_{i=1}^cp^i=\left(1+p+\cdots+p^\frac{c-1}{2}\right)+\left(p^\frac{c+1}{2}+\cdots+p^c\right)\\=\left(1+p+\cdots+p^\frac{c-1}{2}\right)+p^\frac{c+1}{2}*\left(1+p+\cdots+p^\frac{c-1}{2}\right)\\=(1+p^\frac{c+1}{2})*\sum_{i=1}^\frac{c+1}{2}p^i\] 若c为偶数，类似有: \[\sum_{i=1}^cp^i=(1+p^\frac{c}{2})*\sum_{i=1}^{\frac{c}{2}-1}p^i+p^c\] [点击显示/隐藏代码] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;#define ll long longconst ll N = 1005, MOD = 9901;pair&lt;ll, ll&gt; fac[N];ll cnt = 0;ll qpow(ll a, ll b)&#123; ll res = 1; for (; b; b &gt;&gt;= 1, a = a * a % MOD) if (b &amp; 1) res = res * a % MOD; return res;&#125;ll sum(ll p, ll c)&#123; if (!c) return 1; if (c &amp; 1) return (qpow(p, (c + 1) / 2) + 1) * sum(p, c / 2) % MOD; return ((qpow(p, c / 2) + 1) * sum(p, c / 2 - 1) + qpow(p, c)) % MOD;&#125;void divide(ll n)&#123; for (ll i = 2; i * i &lt;= n; ++i) &#123; if (n % i == 0) &#123; ll num = 0; while (n % i == 0) &#123; num++; n /= i; &#125; fac[++cnt] = make_pair(i, num); &#125; &#125; if (n &gt; 1) fac[++cnt] = make_pair(n, 1);&#125;int main()&#123; ll a, b; scanf("%lld%lld", &amp;a, &amp;b); divide(a); ll ans = 1; for (ll i = 1; i &lt;= cnt; ++i) &#123; ll p = fac[i].first, c = fac[i].second; ans = ans * sum(p, b * c) % MOD; &#125; printf("%lld\n", a == 0 ? 0 : ans); return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python简易网络爬虫]]></title>
    <url>%2F2019%2F04%2F27%2FPython%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[上大学后自学了点爬虫, 下面是我个人的学习总结 正则表达式 基本概念 正则表达式(regular expression)，又称规则表达式。正则表达式通常被用来检索、替换那些符合某个模式(规则)的文本。 正则表达式的语法 正则表达式语法由字符和操作符构成 正则表达式的常用操作符 操作符 说明 实例 . 表示任何单个字符 [ ] 字符集, 对单个字符给出取值范围 [abc]表示a、b、c, [a-z]表示a到z单个字符 [^ ] 非字符集, 对单个字符给出排除范围 [^abc]表示非a或b或c的单个字符 * 前一个字符0次或无限次扩展 abc*表示ab、abc、abcc、abccc等 + 前一个字符1次或无限次扩展 abc+表示abc、abcc、abccc等 ? 前一个字符0次或1次扩展 abc?表示ab、abc | 左右表达式任意一个 abc|def表示abc、def {m} 扩展前一个字符m次 ab{2}c表示abbc {m,n} 扩展前一个字符m至n次(含n) ab{1,2}表示abc、abbc ^ 匹配字符串开头 ^abc表示abc且在一个字符串的开头 $ 匹配字符串结尾 abc&amp;表示abc且在一个字符串的结尾 ( ) 分组标记, 内部只能使用|操作符 (abc)表示abc、(abc|def)表示abc、def \d 数字, 等价于[0-9] \D 非数字字符, 等价于[^0-9] \w 单词字符(包括下划线), 等价于[A-Za-z0-9_] \W 非单词字符, 等价于[^A-Za-z0-9_] \s 空白字符, 等价于[\f\n\r\t\v] \S 非空白字符, 等价于[^\f\n\r\t\v] Re库默认采用贪婪匹配, 即输出匹配最长的子串 最小匹配操作符 操作符 说明 *? 前1个字符0次或无限次扩展 +? 前1个字符1次或无限次扩展 ?? 前1个字符0次或1次扩展 {m,n}? 扩展前1个字符m次至n次 始位置匹配一个模式，如果不是起始位置匹配成功的话，match()就返回none。 表达式 意义 ^[A-Za-z]+$ 由26个字母组成的字符串 ^[A-Za-z0-9]+$ 由26个字母和数字组成的字符串 ^-?\d+$ 整数形式的字符串 ^[0-9]\*[1-9][0-9]*$ 正整数形式的字符串 [1-9]\d{5} 中国境内邮政编码, 6位 [\u4e00-\u9fa5] 匹配中文字符 \d{3}-\d{8}|\d{4}-\d{7} 国内电话号码, 010-68913536 (([1-9]?\d|1\d{2}|2[0-4]\d|25[0-5]).){3}(([1-9]?\d|1\d{2}|2[0-4]\d|25[0-5])) 匹配IP地址 Re库的基本使用 raw string类型, 是不包含对转义符再次转义的字符串: r'text' re.search(pattern, string, flags=0) 从字符串的起始位置匹配, 如果不是起始位置匹配成功的话, match()就返回none pattern: 正则表达式的字符串或原生字符串表示 string: 待匹配字符串 flags: 正则表达式使用时的控制标记 修饰符 说明 re.I(re.IGNORECASE) 使匹配对大小写不敏感 re.M(re.MULTILINE) 多行匹配, 正则表达式的^操作符能将给定字符串的每行当作匹配开始 re.S(re.DOTALL) 正则表达式的.操作符能够匹配所有字符串, 默认匹配除换行外的所有字符 123456&gt;&gt;&gt; import re&gt;&gt;&gt; match = re.search(r'[1-9]\d&#123;5&#125;', 'Hunanyz 425000')&gt;&gt;&gt; if match: print(match.group(0))425000 12345678910111213#!/usr/bin/python3import reline = "Cats are smarter than dogs";searchObj = re.search( r'(.*) are (.*?) .*', line, re.M|re.I)if searchObj: print ("searchObj.group() : ", searchObj.group())#searchObj.group() : Cats are smarter than dogs print ("searchObj.group(1) : ", searchObj.group(1))#searchObj.group(1) : Cats print ("searchObj.group(2) : ", searchObj.group(2))#searchObj.group(2) : smarterelse: print ("Nothing found!!") re.match(pattern, string, flags=0) re.match 从第一个字符串的开始位置起匹配正则表达式, 返回match对象 group(num=0): 匹配的整个表达式的字符串，group() 可以一次输入多个组号，在这种情况下它将返回一个包含那些组所对应值的元组。 groups(): 返回一个包含所有小组字符串的元组，从 1 到 所含的小组号。 12345678910111213141516&gt;&gt;&gt; import re&gt;&gt;&gt; match = re.match(r'[1-9]\d&#123;5&#125;', 'Hunanyz 425000')&gt;&gt;&gt; if match: match.group(0) &gt;&gt;&gt; match.group(0)Traceback (most recent call last): File "&lt;pyshell#15&gt;", line 1, in &lt;module&gt; match.group(0)AttributeError: 'NoneType' object has no attribute 'group'&gt;&gt;&gt; match = re.match(r'[1-9]\d&#123;5&#125;', '425000 Hunanyz')&gt;&gt;&gt; if match: match.group(0)'425000' 函数式用法: 一次性操作 1&gt;&gt;&gt; rst = re.search(r'[1-9]\d&#123;5&#125;', 'Hunanyz 425000') 面向对象用法: 编译后的多次操作 12&gt;&gt;&gt; pat = re.compile(r'[1-9]\d&#123;5&#125;')&gt;&gt;&gt; rst = pat.search('Hunanyz 425000') re.findall(pattern, string, flags=0) 123&gt;&gt;&gt; import re&gt;&gt;&gt; re.findall(r'[1-9]\d&#123;5&#125;','Hunanyz425000 ywt666666')['425000', '666666'] re.split(pattern, string, maxsplit=0, flags=0) 12345&gt;&gt;&gt; import re&gt;&gt;&gt; re.split(r'[1-9]\d&#123;5&#125;','Hunanyz425000 ywt666666')['Hunanyz', ' ywt', '']&gt;&gt;&gt; re.split(r'[1-9]\d&#123;5&#125;','Hunanyz425000 ywt666666', maxsplit=1)['Hunanyz', ' ywt666666'] re.finditer(pattern, string, flags=0) 1234567&gt;&gt;&gt; import re&gt;&gt;&gt; for m in re.finditer(r'[1-9]\d&#123;5&#125;', 'Hunanyz425000 ywt666666'): if m: print(m.group(0)) 425000666666 re.sub(pattern, repl, string, count=0, flags=0) 123&gt;&gt;&gt; import re&gt;&gt;&gt; re.sub(r'[1-9]\d&#123;5&#125;', ':zipcode','Hunanyz425000 ywt666666')'Hunanyz:zipcode ywt:zipcode' 可以在https://regex101.com/进行练习 简单应用举例 淘宝商品比价定向爬虫 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#CrawTaobaoPrice.pyimport requestsimport re def getHTMLText(url): try: cookies = &#123;&#125; cookiestext = 'miid=447214471620210220; t=daacc1adb7b8d8ce463fc06d0450c7ce; _m_h5_tk=002873f26cfc1e420ff3122c5492c7c9_1557484529238; _m_h5_tk_enc=65acce1ae24f182e94781af0151760a8; cna=eEfQE0Z7LH0CAXFJnusRzYTI; thw=cn; v=0; cookie2=1daeaf566f932421be0293c558854e53; _tb_token_=e4714b1e4b700; skt=fe7483af86fc3fa7; csg=c58e3cb2; uc3=vt3=F8dBy3qLpz1EFG7igHg%3D&amp;id2=Uone%2BIX5BNoxeA%3D%3D&amp;nk2=F5RMHlysDcyBUg%3D%3D&amp;lg2=VFC%2FuZ9ayeYq2g%3D%3D; existShop=MTU1NzQ3NDQ5MA%3D%3D; tracknick=tb97668932; lgc=tb97668932; _cc_=W5iHLLyFfA%3D%3D; dnk=tb97668932; tg=0; enc=3ukH3QlCeyiQ6MFTauMNgLvWKWnuXa3Jw3n2WhkpKJAmlq33XogQu8U1mIK3erlfcBDcFlwD%2B0PqC6mRrGzvUQ%3D%3D; mt=ci=110_1; hng=CN%7Czh-CN%7CCNY%7C156; x=e%3D1%26p%3D*%26s%3D0%26c%3D0%26f%3D0%26g%3D0%26t%3D0; swfstore=213919; uc1=cookie15=U%2BGCWk%2F75gdr5Q%3D%3D&amp;cookie14=UoTZ48F1Orvnkg%3D%3D; alitrackid=www.taobao.com; lastalitrackid=www.taobao.com; JSESSIONID=779A7AFFB8D472B89FE1153556AA5258; l=bBxX6XbVv0FzD8MSBOCg5uI8aPbOSLAAIuPRwNcXi_5N-6L6Vd_OlL6deFp6Vj5RO6TB4XEDz5w9-etui; isg=BGRk0tuo5AKzCBDOAudCpWpJIGKWVYgCO075jX6F8C_yKQTzpg1Y95oL6cGU0MC_' kv = &#123;'user-agent': 'Mozilla/5.0'&#125; for line in cookiestext.split(';'): name,value = line.strip().split('=',1) cookies[name] = value r = requests.get(url,headers = kv, cookies=cookies, timeout=30) r.raise_for_status() r.encoding = r.apparent_encoding return r.text except: return ""def parsePage(ilt, html): plt = re.findall(r'\"view_price\"\:\"[\d\.]*\"',html) tlt = re.findall(r'\"raw_title\"\:\".*?\"',html) for i in range(len(plt)): price = eval(plt[i].split(':')[1]) title = eval(tlt[i].split(':')[1]) ilt.append([price, title])def printGoodsList(ilt): tplt = "&#123;:4&#125;\t&#123;:8&#125;\t&#123;:16&#125;" print(tplt.format("序号", "价格", "商品名称")) count = 0 for g in ilt: count = count + 1 print(tplt.format(count, g[0], g[1])) def main(): goods = '书包' depth = 3 start_url = 'https://s.taobao.com/search?q=' + goods infoList = [] for i in range(depth): try: url = start_url + '&amp;s=' + str(44*i) html = getHTMLText(url) parsePage(infoList, html) except: continue printGoodsList(infoList)main() 关于淘宝反爬的解决 关于爬虫的深入学习将在后续发布]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[部分写作知识点小结]]></title>
    <url>%2F2019%2F01%2F03%2F%E5%8D%9A%E5%AE%A2%E5%86%99%E4%BD%9C%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[本文将主要介绍一些关于博客写作的小知识点(防遗忘) pandoc教程 水的一篇好文 Markdown Markdown教程现在已经烂大街了，在这里主要是作为备忘录进行查阅。 公式 插入公式与代码分别是用$与 ` 符号(～键)包裹所写部分 在需要高亮的代码块的前一行及后一行使用三个反引号。 同时第一行反引号后面，写代码块所使用的语言。 使用 \left和 \right来创建自动匹配高度的 ()，[] 和 {} 。 在每个公式末尾前使用\tag{行标}来实现行标。 希腊字母 显示 大写 命令 显示 大写 命令 \(\alpha\) \(\rm{A}\) $\alpha$ \(\beta\) \(\rm{B}\) $\beta$ \(\gamma\) \(\Gamma\) $\gamma$ \(\delta\) \(\Delta\) $\delta$ \(\epsilon\) \(\rm{E}\) $\epsilon$ \(\zeta\) \(\rm{Z}\) $\zeta$ \(\eta\) \(\rm{H}\) $\eta$ \(\theta\) \(\Theta\) $\theta$ \(\iota\) \(\rm{I}\) $\iota$ \(\kappa\) \(\rm{K}\) $\kappa$ \(\lambda\) \(\Lambda\) $\lambda$ \(\mu\) \(\rm{M}\) $\mu$ \(\nu\) \(\rm{N}\) $\nu$ \(\xi\) \(\Xi\) $\xi$ \(\pi\) \(\Pi\) $\pi$ \(\rho\) \(\rm{R}\) $\rho$ \(\sigma\) \(\Sigma\) $\sigma$ \(\tau\) \(\rm{T}\) $\tau$ \(\upsilon\) \(\Upsilon\) $\upsilon$ \(\phi\) \(\Phi\) $\phi$ \(\chi\) \(\rm{X}\) $\chi$ \(\psi\) \(\Psi\) $\psi$ \(\omega\) \(\Omega\) $\omega$ :只需将命令的首字母大写即可得大写希腊字母，在命令前加上var前缀即可得到斜体希腊字母如: \(\Gamma\phi\) &amp; \(\varGamma\varphi​\) 1$\Gamma\phi$ &amp; $\varGamma\varphi​$ 运算 命令 显示 命令 显示 $\pm$ \(\pm\) $\mp$ \(\mp\) $\neq$ \(\neq\) $\times$ \(\times\) $\div$ \(\div\) $\leq$ \(\leq\) $\geq$ \(\geq\) $\ngeq$ \(\ngeq\) $\ast$ \(\ast\) $\approx$ \(\approx\) $\equiv$ \(\equiv\) $bigcup$ \(\bigcup\) $\iint$ \(\iint\) $\iiint$ \(\iiint\) $\oint$ \(\oint\) $\mid$ \(\mid\) $\because$ \(\because\) \therefore \(\therefore\) 特殊符号 显示 命令 显示 命令 \(\infty\) $\infty$ \(\cup\) $\cup$ \(\cap\) $\cap$ \(\subset\) $\subset$ \(\subseteq\) $\subseteq$ \(\supset\) $\supset$ \(\in\) $\in$ \(\notin\) $\notin$ \(\varnothing\) $\varnothing$ \(\forall\) $\forall$ \(\exists\) $\exists$ \(\lnot\) $\lnot$ \(\nabla\) $\nabla$ \(\partial\) $\partial$ \(\angle\) $\angle$ \(\bot\) $\bot$ \(\bigodot\) $\bigodot$ \(\bigotimes\) $\bigotimes$ 空格 $\,$ \(\frac{1}{6}\)m宽度 $\;$ \(\frac{2}{7}\)m宽度 $\$ \(\frac{1}{3}\)m宽度 $\quad$ m宽度 $\qquad$ 2m宽度 矢量与箭头 命令 显示 命令 显示 $\vec{a}$ \(\vec{a}\) $\bar{s}$ \(\bar{s}\) (平均值) $\rightarrow$ \(\rightarrow\) $\Rightarrow$ \(\Rightarrow\) $\overrightarrow{a}$ \(\overrightarrow{a}\) $\overleftrightarrow{a}$ \(\overleftrightarrow{a}\) $\overleftarrow{a}$ \(\overleftarrow{a}\) $\longrightarrow$ \(\longrightarrow\) $\overline{a+b}$ \(\overline{a+b}\) $\underline{a+b}$ \(\underline{a+b}\) $\overbrace{a+\underbrace{b+c}_{1.0}+d}^{2.0}$ \(\overbrace{a+\underbrace{b+c}_{1.0}+d}^{2.0}\) $\hat{y}$ \(\hat{y}\) 矩阵与方程组 pmatrix: $\begin{pmatrix}1 &amp; 2 \\ 3 &amp; 4\\ \end{pmatrix}$ : \[\begin{pmatrix}1 &amp; 2 \\ 3 &amp; 4\\ \end{pmatrix}\] bmatrix: $\begin{bmatrix}1 &amp; 2 \\ 3 &amp; 4\\ \end{bmatrix}$ : \[\begin{bmatrix}1 &amp; 2 \\ 3 &amp; 4\\ \end{bmatrix}\] Bmatrix: $\begin{Bmatrix}1 &amp; 2 \\ 3 &amp; 4\\ \end{Bmatrix}$ : \[\begin{Bmatrix}1 &amp; 2 \\ 3 &amp; 4\\ \end{Bmatrix}\] vmatrix: $\begin{vmatrix}1 &amp; 2 \\ 3 &amp; 4\\ \end{vmatrix}$ : \[\begin{vmatrix}1 &amp; 2 \\ 3 &amp; 4\\ \end{vmatrix}\] Vmatrix: $\begin{Vmatrix}1 &amp; 2 \\ 3 &amp; 4\\ \end{Vmatrix}$ : \[\begin{Vmatrix}1 &amp; 2 \\ 3 &amp; 4\\ \end{Vmatrix}\] 12345678910111213141516171819$$\begin&#123;matrix&#125;a_&#123;11&#125;&amp;a_&#123;12&#125;&amp;\cdots&amp;a_&#123;1n&#125;\\a_&#123;21&#125;&amp;a_&#123;21&#125;&amp;\cdots&amp;a_&#123;2n&#125;\\\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\a_&#123;n1&#125;&amp;a_&#123;n2&#125;&amp;\cdots&amp;a_&#123;nn&#125;\\\end&#123;matrix&#125;$$(类似有\ldots底端对齐)$$\left\&#123;\begin&#123;array&#125;\a_1x + a_2y + a_3z = d_1 \\b_1x + b_2y + b_3z = d_2 \\\end&#123;array&#125;\right.$$(array亦可改为cases)$$\begin&#123;cases&#125; a_&#123;11&#125;x_1&amp;+&amp;a_&#123;12&#125;x_2&amp;+&amp;\cdots&amp;+a_&#123;1n&#125;x_n&amp;=&amp;b_1\\ &amp;&amp;&amp;&amp;\vdots\\ a_&#123;n1&#125;x_1&amp;+&amp;a_&#123;n2&#125;x_2&amp;+&amp;\cdots&amp;+a_&#123;nn&#125;x_n&amp;=&amp;b_n&amp; \end&#123;cases&#125;$$ \[\begin{matrix}a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1n}\\\ \ a_{21}&amp;a_{21}&amp;\cdots&amp;a_{2n}\\\ \ \vdots &amp; \vdots &amp; \ddots &amp; \vdots\\\ \ a_{n1} &amp; a_{n2} &amp; \cdots &amp; a_{nn}\\\ \end{matrix}\] \[\begin{cases} ​ a_{11}x_1&amp;+&amp;a_{12}x_2&amp;+&amp;\cdots&amp;+a_{1n}x_n&amp;=&amp;b_1\\\ &amp;&amp;&amp;&amp;\vdots\\\ a_{n1}x_1&amp;+&amp;a_{n2}x_2&amp;+&amp;\cdots&amp;+a_{nn}x_n&amp;=&amp;b_n&amp; \end{cases}\] 公式快速参考 表情 syntax preview syntax preview :sun_with_face: 🌞 :smile: 😄 :laughing: 😆 :blush: 😊 :smiley: 😃 :relaxed: ☺️ :smirk: 😏 :heart_eyes: 😍 :kissing_heart: 😘 :kissing_closed_eyes: 😚 :flushed: 😳 :relieved: 😌 :satisfied: 😆 :grin: 😁 :wink: 😉 :stuck_out_tongue_winking_eye: 😜 :stuck_out_tongue_closed_eyes: 😝 :grinning: 😀 :kissing: 😗 :kissing_smiling_eyes: 😙 :stuck_out_tongue: 😛 :sleeping: 😴 :worried: 😟 :frowning: 😦 :anguished: 😧 :open_mouth: 😮 :confused: 😕 :hushed: 😯 :expressionless: 😑 :unamused: 😒 :sweat_smile: 😅 :sweat: 😓 字体 输入 说明 实例 输入 说明 实例 $\rm{D}$ 罗马体 \(\rm{D}\) $\cal{D}$ 花体 \(\cal{D}\) $\it{D}$ 意大利体 \(\it{D}\) $\Bbb{D}$ 黑板粗体 \(\Bbb{D}\) $\bf{D}$ 粗体 \(\bf{D}\) $\mit{D}$ 数学斜体 \(\mit{D}\) $\sf{D}$ 等线体 \(\sf{D}\) $\scr{D}$ 手写体 \(\scr{D}\) $\tt{D}$ 打字机体 \(\tt{D}\) $\boldsymbol{D}$ 黑体 \(\boldsymbol{D}\) 颜色 命令 命令 显示 $\color{red}{红色}$ &lt;font color=#FF0000&gt;红色&lt;/font&gt; 红色 $\color{green}{绿色}$ &lt;font color=#00FF00&gt;绿色&lt;/font&gt; 绿色 $\color{blue}{蓝色}$ &lt;font color=#0000FF&gt;蓝色&lt;/font&gt; 蓝色 $\color{cyan}{青色}$ &lt;font color=#00FFFF&gt;青色&lt;/font&gt; 青色 $\color{yellow}{黄色}$ &lt;font color=#FFFF00&gt;黄色&lt;/font&gt; 黄色 $\color{purple}{紫色}$ &lt;font color=#FF00FF&gt;紫色&lt;/font&gt; 紫色 $\color{orange}{橙色}$ &lt;font color=#FF6100&gt;橙色&lt;/font&gt; 橙色 标题 12# 一级标题###### 六级标题 字体 1234**加粗文字** 对应 &lt;b&gt;加粗文字&lt;/b&gt; 及 &lt;strong&gt;加粗文字&lt;/strong&gt;*倾斜文字* 对应 &lt;i&gt;倾斜文字&lt;/i&gt; 及 &lt;em&gt;倾斜文字&lt;/em&gt;***斜体加粗文字*** ~~加删除线文字~~ 对应 &lt;del&gt;加删除线文字&lt;/del&gt; 引用 多个&gt;用于逐层嵌套 12&gt;引用内容&gt;&gt;引用内容 分割线 三个或者三个以上的 - 或者 *,效果一样 12---*** 图片或链接 1234567![图片说明](图片地址 ''title'')[超链接名](超链接地址 "title")title可加可不加如:[百度](http://www.baidu.com)&lt;a href="http://www.baidu.com"&gt;百度&lt;/a&gt;![风景](https://upload-images.jianshu.io/upload_images/703764-605e3cc2ecb664f6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) 百度 列表 无序列表使用*或+或-标识 有序列表使用数字加.标识，例如：1. 表格 短斜杠(数量至少有一个)左右的冒号用于控制对齐方式，只放置左边冒号表示文字居左，只放置右边冒号表示文字居右，如果两边都放置冒号表示文字居中。 1234表头|条目一|条目二:-:|:-:|:-:1|2|34|5|6 表头 条目一 条目二 1 2 3 4 5 6 \(pandoc\)版\(markdown\)与标准版的区别 标准Markdown语法并不要求在标题前添加一个空行，但是Pandoc语法却要求标题前添加一个空行（除了文档开头） Html 学习的地方 基本文档 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;文档标题&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 可见文本... &lt;/body&gt; &lt;p&gt;这是一个段落。&lt;/p&gt; &lt;br&gt; （换行）&lt;/html&gt; 基本元素 粗体文粗体文本 int exgcd(int x, int y, int &amp;a, int &amp;b) { if (y == 0) { return a = 1, b = 0, x; } else { int g = exgcd(y, x % y, b, a); b -= x / y * a; return g; } } 强调文本 斜体文本 键盘输入 预格式化文本 更小的文本 重要的文本 缩写 联系信息 文字方向 从另一个源引用的部分 工作的名称 删除的文本 插入的文本下标文本上标文本本 1234567891011121314151617181920212223242526&lt;b&gt;粗体文本&lt;/b&gt;&lt;code class=&quot;language-cpp&quot;&gt;int exgcd(int x, int y, int &amp;a, int &amp;b) &#123; if (y == 0) &#123; return a = 1, b = 0, x; &#125; else &#123; int g = exgcd(y, x % y, b, a); b -= x / y * a; return g; &#125;&#125;&lt;/code&gt;&lt;em&gt;强调文本&lt;/em&gt;&lt;i&gt;斜体文本&lt;/i&gt;&lt;kbd&gt;键盘输入&lt;/kbd&gt; &lt;pre&gt;预格式化文本&lt;/pre&gt;&lt;small&gt;更小的文本&lt;/small&gt;&lt;strong&gt;重要的文本&lt;/strong&gt;&lt;abbr&gt;缩写&lt;/abbr&gt;&lt;br&gt;&lt;address&gt;联系信息&lt;/address&gt;&lt;bdo&gt;文字方向&lt;/bdo&gt;&lt;blockquote&gt;从另一个源引用的部分&lt;/blockquote&gt;&lt;cite&gt;工作的名称&lt;/cite&gt; &lt;del&gt;删除的文本&lt;/del&gt; &lt;ins&gt;插入的文本&lt;/ins&gt;&lt;sub&gt;下标文本&lt;/sub&gt;&lt;sup&gt;上标文本&lt;/sup&gt;本&lt;/b&gt; 列表与表格 Coffee Milk Cola sara &lt;dt&gt;Coffee&lt;/dt&gt;&lt;!--自定义列表项目--&gt;&lt;dd&gt;- Black hot drink&lt;/dd&gt;&lt;!--自定义列表项目--&gt; &lt;dt&gt;Milk&lt;/dt&gt;&lt;dd&gt;- White cold drink&lt;/dd&gt; 123456789101112131415161718192021222324&lt;ul&gt;&lt;!--无序列表--&gt; &lt;li&gt;Coffee&lt;/li&gt;&lt;li&gt;Milk&lt;/li&gt;&lt;/ul&gt;&lt;ol&gt;&lt;!--有序列表--&gt; &lt;li&gt;Cola&lt;/li&gt;&lt;li&gt;sara&lt;/li&gt;&lt;/ol&gt;&lt;dl&gt;&lt;!--定义列表--&gt; &lt;dt&gt;Coffee&lt;/dt&gt;&lt;!--自定义列表项目--&gt;&lt;dd&gt;- Black hot drink&lt;/dd&gt;&lt;!--自定义列表项目--&gt; &lt;dt&gt;Milk&lt;/dt&gt;&lt;dd&gt;- White cold drink&lt;/dd&gt;&lt;/dl&gt;&lt;table border="1"&gt; &lt;tr&gt; &lt;th&gt;Header 1&lt;/th&gt;&lt;th&gt;Header 2&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;row 1, cell 1&lt;/td&gt;&lt;td&gt;row 1, cell 2&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;row 2, cell 1&lt;/td&gt;&lt;td&gt;row 2, cell 2&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 图片 普通的链接：百度 图像链接： 邮件链接： 发送e-mail 书签： 提示部分 跳到提示部分 #### 框架 document.write("Hello World!") 抱歉，你的浏览器不支持 JavaScript!]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>小知识</tag>
      </tags>
  </entry>
</search>
